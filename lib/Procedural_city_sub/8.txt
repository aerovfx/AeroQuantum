1   If you have ever rendered something, then you are undoubtedly familiar with the problem of color control.  Since this week we will be engaged in lighting, rendering and composing,  I think it is worth checking that we have color spaces set up correctly.  And you can't discuss color spaces without first talking about ACES.  What is it?  ACES is a color coding system of the Academy, and it is considered a standard of the industry.  Probably, this is not much if you don't know what it is for.  If in a nutshell, when we render an image or photograph something,  we create or use unprocessed data.  In the standard working process, they are stored in the EXR format  or in another format with a high dynamic range.  In the case of the XR format, the data is stored in the EXR format.  And this range of value is usually very wide,  so we need a way to return it to visible color spaces,  available to the monitor and our eyes.  And here color control comes to help.  In the past, we had many different ways of processing these images,  sometimes contradictory, especially if they were obtained from different sources.  And ACES allows you to process images from different sources in the same way,  doing it consistently and predictably.  But what does it mean for us, and how is it applicable to our work?  In practice, this happens in two stages.  This is how we view what we do during work,  as well as how we control the results when we want to transfer to other programs.  But before we get to all this, we first need to understand how to configure it in Houdini.  To begin with, this package needs to be loaded.  And it can be found on this page on GitHub.  I showed you the link on the screen.  So, you download this package, and as soon as you finish,  you need to open the Houdini.env file, your folder with documents.  So, we loaded the file, open the folder with documents,  and open this file with Houdini.env rows.  And in this file we write the following.  This is the path to your configuration.  And if you find this folder,  here will be the folder aces103.  Here it is, the configuration.  This path points to this particular file.  You write this line, save it, and then you can open Houdini.  And now we go to Houdini, you should see this panel.  If these parameters are not displayed, then in the Edit menu you need to find Color Settings.  And you should have this path here.  It should also point to the desired file.  And now here you will have the aces menu at the bottom, and here are different options.  And in the Rock node, the parameters can be different, depending on what you render.  Here I can go to the Properties tab, then Device,  and you need to check that the Color Space Rock flag is enabled.  And now the rendered images will be in this Color Space.  And we can apply aces transform during the compose.  Well, that's it, it was a very simple explanation of what aces is and how it is applicable to our working process.  If you want to know more about this, then you can read on that page, there is a lot of information,  but I decided not to complicate and tell only what is important for us at the moment.  And then in the next video we will start to configure the main lighting of our scene. 
﻿1 After we have sorted out the color space, let's set up the lighting.  It is important to decide as early as possible which areas will be light, that is, illuminated, and which ones are dark.  Because it will allow you to focus on those areas that, as we know, will be seen best.  And this also helps when creating a composition.  And what you have on the image is the most contrasting will usually be the area that the viewer will look at most.  Before we continue, I want to emphasize the importance of lighting the scene.  This should be the first thing you pay attention to when working on a new environment.  In normal circumstances, I would immediately turn on the main lighting and the sky before the start of modeling.  So, in Houdini, I have already created my city, created the layout.  At the same time, I used the same methods that we were considering.  In some places I have a procedural city, somewhere a library building, this is a building that can be considered nearby.  Some are located in the center, some are made specifically for a large plan.  For example, this is a tower and a temple in the distance.  And these are the places that are closer to the foreground.  I already have a camera, we set it up before.  Now, before adding lighting, I want to add a gray shader to this scene.  For rendering, I will use Arnold, but most of this process is applicable to any engine.  So, to create a shader, you could create materials in the context of matte.  But I want to use ShopNet, so that it is easier to create an asset later.  Now I will add Arnold Shader Network here and inside Standard Surface.  Now I will just show you how to add the material that we will consider and analyze a little later.  We connect this one here and now in Standard Surface we change the color to 02.  Or, more precisely, 0.2.  We change the color to 02.  Or, more precisely, 0.18.  This is about 50% gray.  This is if you have PBR rendering.  And I will also change the Roughness to 1 so that we do not have distracting reflections.  Well, that's it, so far this is enough.  Now we go to the Out context.  This is Arnold's render node.  To add such a node, if you want to use Arnold, just type Arnold in the menu and this node will be here.  If you have Redshift or Mantra, you do the same.  Mantra, Render, Rope and Redshift, Rope.  I will use this preview node.  And we will consider the render settings a little later.  Now I just want to draw your attention to a couple of points.  The first thing is to choose the right camera.  The second thing is to add something here, Shader Override.  I will find my gray shader.  So.  And finally, on the Properties tab, we need to check everywhere that there are units.  By default, there are usually two.  And there should be three samples for the camera.  But of course, so far I have no light source.  I will return to the Object level.  I will add Arnold Light.  And here I will select Skydome.  Here we select the texture and let long.  We will add the texture a little later, we just set everything up as it should be.  And now let's run the render and see what we get.  Great, we just have everything gray.  Also note that I already have a motion blur on the camera.  We will discuss this a little later.  And now I will add a little more.  And I will add a little more.  And now I will add a little more.  And now I will add a little more.  And now I will add a little more.  And now I will add a little more.  And now I will add a little more.  And now I will add a little more.  And we're good.  And as always, we will simply render the image.  We will discuss this a little later.  The lighting of the environment can be very simple, and in many ways it looks like real life.  Most often we need the sun and the sky, and even more often just the sky.  If we look at my references again, then here we have such lighting with twilight and warm, saturated sky.  In general, when it comes to setting up the lighting of the environment, there is only one rule, this is sequence.  So that you do not choose for lighting the time of day, direction of light, and so on, all elements must be coordinated with each other.  That is, the HDRI that you choose, the sky in the background, and the direction of the sun, all this should be logical, everything should combine with each other.  That is, you choose one option and adhere to it.  I usually look for HDR images on several sites. This is HDR for lighting the environment and background.  One of them is matpaint.org, and here, which is very cool, there is an HDRI tab, and here you can choose from the sky at any time of day.  And you can easily download and use them to light your environment.  And here is another option, sky backplates. They can also be filtered over the time of day.  For example, in categories you can find twilight.  And here you choose what suits you. HDR and so on.  Another site is photobash.org.  I would not look for HDR images here, but there are a lot of cool background images and references that will be useful for working on lighting your scene.  If you want to get a realistic result.  So, okay, let's go back to Houdini and find the HDRI that I downloaded.  And as you can see, everything is already set up here.  Here you need to select linear space.  And so now we have HDRI and our scene. Let's talk a little about the effectiveness.  While we are working on lighting, we will have to render very often.  Therefore, I would like to perform iterations as quickly as possible.  And for this you need to reduce the render settings.  Let's look again at Arnold Rope.  On the main tab, I have already selected our ShotCam camera.  And here you can also select a certain frame range.  By default, Fstart and Fend are set here.  These are the variables that return the beginning and end of your time scale.  And on the right there are still steps.  That is, how many frames we want to render and save on the disk.  At the moment, each frame will be rendered. If there are 10, then every tenth frame will be rendered.  This is also a very useful option when you render the sequence and check.  So you can only test what you need to see before you perform the final rendering.  And while we are working, we need to check the camera resolution.  It should be low enough, but at the same time I still have to be able to assess the final result.  If you want to reduce it by 4 times and it suits you, then of course you can choose this resolution.  Now the main thing for us is that the renders are very fast, so that we can make decisions quickly.  I have a low sampling, there are only three.  And I also reduced the number of samples from these different channels.  When we move on to the final stage of rendering, we will discuss what it is, why and how it affects the final result.  And what can be done to reduce the final rendering time.  I also mentioned Motion Blur. This blur is turned on here.  I usually turn on blur right now, because it does not greatly increase the rendering time,  but it helps to understand what you need to pay special attention to,  because we can spend a lot of time on areas that we don't even need.  You may think that you will see these areas, but then you turn on Motion Blur and understand that most of the image  is blurred here. Therefore, I turn it on right now at the initial stage,  so that I can make the right decisions in the future.  And the last thing I want to reduce is the depth of the rays. This again simply reduces the rendering time.  We will come back and increase all this when we reach the final stage.  And now our renders will be performed much faster.  That is, I can perform iterations faster and it will be easier for me to work.  You also need to understand the difference between rendering time and geometry loading time.  If I click Render, then at the beginning of the scene in the render engine,  Houdini and Arnoldo need time to create a scene.  And the more geometry, the longer it will take.  Especially if you have not created instances or have not cached enough.  And after the rendering starts, when everything is loaded,  from this moment you start counting the rendering time.  This is how much time is required for its calculation.  And it already depends on how much geometry you have, how complex shaders,  how high the rendering settings are.  For example, at this moment you don't need the entire geometry of the scene.  You just need so much so that you can evaluate the lighting, at least at this preliminary stage.  And I also need to make the lighting more intense.  I will add a small light source.  For example, I will add a small light source.  And it's easy.  You understand why you add so much.  You need so much so that you can evaluate the lighting, at this preliminary stage.  If you notice that you spend a lot of time on rendering,  then just try reducing the amount of geometry in the scene first.  And then add it back.  we are already turning on the automatic update.  This means that if I change some lighting settings,  we will not have to wait until this geometry  is loaded into the renderer again.  Let's turn the HDR a little.  I want this color to be behind the temple.  Great.  And maybe if we look again at the reference,  I think we don't need such a big  background from the surrounding light.  We don't need so many shadows.  I think we can reduce it a little.  And we can also control this in Compose.  That is, we can still go back and change this background.  But so far it looks good.  And before we do that,  I want to add the sun.  While I stop rendering.  And I will add another Arnold Light.  I will select Distant.  And I will choose a color that looks more like the sun.  I can take a sample.  I will increase the saturation a little.  I will increase the saturation a little.  I will leave it white, because I will be able to control the intensity  with these values.  And not with the color.  I will throw it into the viewport.  And I will move it through it.  And set it as the sun is directed at HDRI.  Here in this direction.  Oh, no, sorry.  In the direction of the city.  If anything, it can always be moved  after you start rendering.  Great.  And we are already beginning to see the sun's influence.  You can move it.  And you can continue to correct it.  And although this will not be the final lighting,  it would be nice to get something close to the final.  Because this will help us further  at the texturing stage.  And I would also like to increase the angle of the sun's tilt.  Look, there is such a hint.  It helps to adjust this sun more realistically.  I will set the value to 0.5.  And this will soften the shadows  between light and dark places.  Since the sun is hidden somewhere here,  I want the angle to be high enough.  And the higher it is, the softer the shadows become.  So, now when we added the light sources,  we can leave them as they are, and then balance  their contribution later in the composition.  And then we need to consider  a few more lighting processes.  I will tell you about them at the last step  before rendering.  Now I use lighting only to understand  what it can be in the end  when I start creating materials.  And before continuing,  I want to create a more neutral setting.  Something more cloudy.  And so I will have two setups.  Two different lighting types  to test the materials.  I will take and copy HDR.  And I will return it to 1.  And I will find the sky overcast.  I will turn off the sun and the sky.  I will leave the sky covered in clouds.  I took this image on  seigeeskies.com.  This is a free image.  Super! Now we will have such a cloudy sky  covered in clouds.  I will increase the exposure.  Great!  So we prepared the scene  for creating and testing the materials.  Let's go to them.  I will take the image of the sky  and the sky.  And I will turn off the sun. 
﻿1 Translated by the club Translated by all  Before we move on to the setting of procedural materials, we first need to discuss the standard ones.  In this case, this is related to Arnold.  The lesson will be based on the first course.  We will remember what we discussed there.  And it will be based on creating wide, glossy, metallic and translucent materials.  And also how to use maps to control these characteristics.  This will give us a good starting point when moving on to more procedural settings in the next lesson.  And to setting up sheet and water shaders later.  In this lesson, let's continue working on the main asset.  And add materials.  Starting with bricklaying.  This will be an example of a standard material.  But before we start with the material, let's first set up the ROP node for rendering.  In this case, I start from scratch again.  And I need two options.  I will add two nodes.  One setup will be for real lighting shot, and the other for neutral lighting shot.  I will switch between them and check the materials.  For shots in the candidate lights parameter, you can choose sun and sky.  I named them shot sky and shot sun.  And in the neutral node, I will choose neutral sky.  And I will reduce the level of the camera.  In both nodes, I will choose camera cam1.  This is a standard camera, and I will reduce the samples like we did before.  This is just to speed up rendering.  And these values can be increased later if necessary, when we test the renders.  and reduce the resolution of the camera by half.  Now I will set up the camera itself.  To look good, let's change the resolution.  I will make a portrait orientation, not an album one.  And I will increase the focal length.  A little more.  Next, I will create test spheres for the environment.  They will give us a presentation of lighting and will allow us to evaluate its contribution.  In the first course, we discussed what else can be added to evaluate lighting,  but now we just need spheres.  I will add a new geometry node and create three spheres in it.  It researchers will X vendor park and will launch the project.  I will add chosen spheres, so it僕е a lot of people want to take photos for their freezer.  Tolevel the  Light abandoned house and the light sure gay  for three spheres.  There is the tank.  material.  Then I will go to ShopNet and there we will set up these materials.  So we go to ShopNet Arnold and here I will add the standard surface.  I will make it white.  Here I will leave the white one like this.  And as soon as we figure out all the settings, we will come back and figure out the value of albedo.  I will call it white.  This is black, black,  gray  and chrome.  Black will have a value of 0.03.  We already talked about gray, it should be 0.18 or 0.2.  And I will leave a little reflection at gray.  The brightness will be 0.3 or 0.4.  And then chrome.  Here I will leave 0.8, but I will change the metallicity to 1.  And roughness is also a small value.  0.01.  Okay, and let's assign them a sphere in the material node.  Find the network and select the desired material.  Now let's divide this panel into half, to the left and right.  Here we will open the render view.  I will select the camera  and the lighting that we need now.  Let's take the neutral one for now.  And before starting the render, I also want to assign gray material to this building.  To do this, I will go inside and at the end I will add a material node.  So we will redefine all the materials that will be assigned inside.  So, everything is set up, let's run the render.  And let's make the sky a little brighter.  We will make the sky a little darker.  Let's make it brighter, this is a neutral sky.  I will increase the exposure a little.  Let's talk about the environment tests first, before moving on.  Arnold uses the physical rendering engine Raytrace in the standard setup.  This means that we have some idea of what the values can be, depending on the material or surface, depending on what we are trying to recreate.  Now on the Internet you can find a lot of good resources.  For example, this is from the Chris Brijon website.  I will give you a link to this site, there is a lot of useful information about the VFX process in general.  And here are the recommendations of what the Albedo values can be for different materials of different surfaces.  If you look at the lower right corner, there is Fresh Snow, it is fresh snow, it has a value of 0.8.  And in the upper left corner, the value of 0.02 is coal.  That is, these values ​​should be used if you want to recreate such a surface.  Within our scene and in the spheres, we will try to cover the entire range so that we can compare the Albedo values.  So that we can check our materials and understand that we have too dark material, too bright and so on.  That is, we can compare with spheres and understand whether we have problems with light or with material.  So, we have prepared the scene for the Look Dev, now let's add the material.  I will add a new Shopnet.  And inside I will do the same as before.  And now I will add a new Shopnet.  I will call it Hero Lower Brick or Stone.  Inside I will add the Standard Surface again.  And so far I will assign the whole building.  I will remove this path.  And now inside here, let's select this material.  Good.  And now I will add the second layer of the material.  And now I will add the third layer of the material.  Good.  So, this material has all the characteristics that I want to control.  And the first thing we need is Base Color.  To add texture, we take the Image node and connect it here.  This is the RGPA output, connect the base color to the base color.  And now in the File Name parameter we find the texture that we need.  I have already downloaded the texture from Megascans.  Let's find it.  And load it here.  Let's run the render and see what happens.  Great.  Note that some parts of the building have a very large screen.  Note that some parts of the building have a screen, and some do not.  Of course, it would be possible to return and create a screen for all parts of this building.  But we will discuss this in the next lesson.  For now, I will simply add the Triplanar node.  I will connect between them.  So we will have a simple triplanar projection.  And we can change the scale.  As soon as we finish with the scale, we can add other maps for the wide and normal.  And we can add other maps for the wide and normal.  And we can add other maps for the wide and normal.  And we can add other maps for the wide and normal.  We connect the wide and normal to the Specular Roughness.  And the normal needs to be run through the Normal Map node.  Before connecting to the Normal slot.  This slot is located in the geometry section below.  Now let's look at the Image node.  We need to switch the Albedo map to the texture.  Select Utility and Srgb Texture.  And if the map is black and white, then you need to select Rough.  The same with the Normal map.  And we need to select Rough.  And we need to select Rough.  The same with the Normal map.  We will create a completely procedural material in the next lesson.  But for now, to make this more procedural, I will add relative links.  And I will connect the nodes of the triplanar projection.  To make it easier to control.  And to further control the roughness after the triplanar node, I will add the Range node.  It looks like the fitRangeBox node.  The first two parameters are the changes in the range to increase contrast.  And the two lower ones are the black or white amplification.  Look, I reduce.  And we thus increase the glossiness of the material.  And vice versa.  It's very difficult to assess for now.  We need to add some channels to the rough.  I will return to the Out context.  I will select both nodes to work with both at the same time.  And in Outputs we open the AUVs, which we will discuss a little later.  But now I want to add three channels.  AUV is a render of the channels.  Here we select Albedo.  In the second specular.  Here.  And the third is normal.  And now if I run the render.  And we can see what the Albedo map looks like.  What the mirror image input looks like and how normal it looks.  And if I change something in the material, then we will immediately see the update here.  And now we will see the render.  And now we will see the render.  And now we will immediately see the update here.  And it is very convenient to see what happens with the Albedo map.  Also, for the base color, you can add RGB Mix.  It allows you to mix colors.  Let's say if I want more orange, I can add it.  And then in the mix, reduce its input.  You can also add a color correction node CallaCorrect.  If it seems to you that it turns out too dark.  And now I will add a new color correction node.  Well, I think it will do for bricks.  And now we will be able to work on various materials.  Going back to the object.  And instead of adding this material node below for everything.  We go inside and here we already have the material nodes set up.  They are already connected to these setups, to these networks.  That is, each part of the setup passes through the material node.  On this side we have just this wall in the background.  On this side we have old bronze, aged.  And then a few types of skulls.  Here they are here.  Let's set up these materials.  And the first will be the roof skull.  And the second will be the roof skull.  So we also had bronze material.  Let's check what it was called.  And the stone.  I will also copy the name.  I will paste here.  And now let's edit it with retail.  We need another structure.  I will put some other small materials.  And my next concept is보다.  and insert here  ok and let's check the render  so we have some kind of problem with the material  but if you want to change something, it should be updated  and we don't have enough material for this, this is the material roof tiles  roof tiles close up  here we just don't have anything at all, let's add something  and the same with bronze  and again on the background  and create a newake  nice  and finally we need to get rid a liberties  maybe a carpet  ok and the first Removal  Okay, let's start with the roof.  To do this, I'll take the Image node again  and connect it to the color. Now I'll find the Grunge map.  It's just a map with noise. It's a noise similar to clouds.  There will be a kind of pattern that will help us give the surface a certain texture.  Look at the pattern on the roof.  I'll add a color correction node.  I can't multiply with any color.  Super!  In the end, we have such beautiful color transitions on the roof.  And of course you can reduce or increase the contrast.  The same can be connected to the Raffness, the same map.  As for the bronze, we will not add anything special here.  I'll add a little more.  I'll add a little more.  I'll add a little more.  I'll add a little more.  I'll add a little more.  I'll add a little more.  I'll add a little more.  I think it's better this way.  Now bronze.  I'll just change the value.  It's quite light, since it's metal.  Let it be 0.7 and metallicity to 1.  And I'll add color.  Something more similar to bronze.  Let's zoom in a little.  I'll check the albedo.  It's good.  I think you can make it more orange.  And more saturated.  And darker.  And darker.  And darker.  And darker.  And darker.  And darker.  That's it. It will be fine.  It was just a demonstration of how to create materials.  If you have never done them before, especially in Arnold.  Before we proceed to the procedural materials, let's look at the translucent ones.  Let's look at the translucent ones.  Let's go back to the building and check that we have the material for the glass.  Let's go back to the building and check that we have the material for the glass.  Here I have the glass-glass.  And here we have a link to the gray material.  I need to redirect to a new shader.  Now we will create it. It will be called Glass.  And I will save this file again.  Then we go back to ShopNet.  And I will add a new network.  I'll call it Glass.  I want to show you one thing.  If you call Glass 1 as a material and press Render,  then you will constantly see that the scene is being created.  This is because there is simply not enough of this material.  It cannot be found.  To avoid such a problem, you need to go back to your setup  and check that you have the material everywhere.  Now I will add Standard Surface.  Since this is a progressive rendering,  you can run it and continue working with the shader while the render is running.  Again, look, here on top hangs what the scene is created.  It takes a lot of time, so it seems that we still have  somewhere missing material.  Let me check again.  We go to Out and check the data table here.  You need to find ShopMaterialPas.  I will filter this attribute.  And here we have somewhere missing ShopMaterialPas.  I need to check the path again.  I'll save it.  Yes, I just did not reboot.  Now you understand how to solve such a problem.  Let's try again.  Yes, it's fine.  So, the material is there.  Since this is glass, I leave it in white.  If I change it, it will be some other,  then the glass will have such a shade.  And now we change the transmission to 1.  When we have a break.  And then, depending on the type of glass,  you can change the roughness.  And before we finish this lesson,  let me show you something else.  For this rendering, we maximally reduced some settings  to speed up the process.  And now we have a little more.  And some of these settings,  which we have reduced,  are the depth of the ray depth.  If you are not familiar with rendering and do not understand what it is,  then it's just the amount of ray bounce.  The more bounce, the more accurate the rendering becomes.  But more resources go to this.  Since we have a transparent glass now,  it would be nice to increase the number of bounce  to have a more accurate result.  For example, if the transmission is here  at 1, then we will not get any information  behind the glass. We need to increase this value.  If I increase to 2,  nothing will happen, because here the total is still equal to 1.  This is the maximum value.  If I also increase it, then something will start to appear inside.  And here we see part of the light that penetrates through another glass.  If I increase to 4 and 4, we get even more.  And we even see the glass from behind,  through it.  That's all. It was a small demonstration of some simple materials  that we will use in our scene.  These are wood, brick, rough materials, metal and translucent.  And we will consider translucent materials  a little later, when it comes to vegetation and rivers.  Thank you for watching! 
﻿1   To complete the work on the materials for the main scene, let's consider different approaches to procedural shading.  It is not always possible to preferably or necessary to process each object separately.  Although we could afford it in some cases when it comes to objects located close to the camera or the main assets.  But most often procedural approaches are needed to work on the surroundings or the city effectively.  Let's get back to the scene.  And before we move on to procedural shading approaches, let's first consider the work with the overlays.  I have already shown you a triplanar projection in the shader.  And it can be very useful in many cases, but not in all.  There are several methods of working with UV in shading.  I will go into this main asset.  And let's take some part.  Well, this one, for example.  And let's see what can be done with the overlay.  There are several UV nodes that I use.  This is, for example, the UV Project node.  This one.  It is very suitable for cylindrical geometry, like this one.  I press space 5 and open UV View.  Switch to cylindrical.  And I will have the overlay of this tower.  And I can change the scale.  And everything will turn out fine, regardless of the number of windows, whether you will change them or not.  This overlay will always work correctly.  Another tool that I also often use is the After UV Lapse node.  Although it works quite slowly, so I would not use it in the main asset.  But it helps a lot in cases when you cannot use a triplanar projection.  Everything is laid out like this.  And here you can control this overlay in different ways.  There are clusters and so on.  This is another way to create a different layer.  I will go into this layer.  And I will change the color of the layer.  This is another way to create an overlay if you do not have a triplanar projection.  Now I will return to UV Project again.  And I will return to the viewport.  Now here you can turn on the display of UV texture if you have an overlay.  And now you can correct it.  Check the stretching.  There is another option that we have already seen in previous lessons.  I will find the Sweep node.  And as you can see, there is already a pretty good UV texture.  And all this is only due to the Sweep node.  Here you need to turn on Compute UVs.  And here it is already.  And as I usually do, I first turn on Compute UVs here.  And then add UV Flatten.  Just to lay them out in the space from 0 to 1.  Why did I do it here?  When I have such cylindrical shapes, or shapes for which I used the Sweep node,  I can use the Sweep node to create a new layer.  And I need to make sure that the texture of the brick repeats this shape and does not spoil in some places.  And if you use a triplanar node, then in the place where these planes and projections converge, the texture turns out blurred.  Therefore, it is best to use the Sweep node to create a blur here.  And here you need to update the shader.  I will add a new version with UV.  And I will add a new version with UV.  And I will add a new version with UV.  And here you need to update the shader.  I will add a new version with UV.  I have already created it.  Now I will save it again.  And load it back.  And now we see all objects with blur.  And now let's go back to the shaders and I will show the one I have already created.  It is no different from another shader, just it does not have a triplanar projection.  And here, too, the texture of the brick, which I created before, is taken.  Let's switch to the second layer.  And let's see.  Here I have some bug again, it is connected to the color space.  You just need to change something, some parameter and everything will be updated.  Super.  And now you can change the scale.  And at the same time, watch for Albedo.  And now I will add a new layer.  And I will add a new layer.  And I will add a new layer.  And I will add a new layer.  And I will add a new layer.  You can also create this layer.  And I will add item with regular symbols.  I will move it to 박당 date.  And I will add background with frames歐 ahorarice.  And as a result, it already has some interesting remains.  In some singers, or singers of some different national music I felt similar to how I feel here.  But it is at the same time great and well-  At once, wanna recycle one moreonom return im not a link, I'm not bad at writing…  procedural working processes. And for most objects, these procedural methods will be more than enough for us.  To begin with, I want to show you the Round Edge node.  Oh, sorry, it's called Round Corners. I'll add it after the normal map.  And here I will select the render area from the shift so that we can only view it. And we will compare before and after.  I'll skip this node, save the photos,  I'll render.  I need to change the parameters.  Okay, now I'll save the photos, this is before, and connect the Round Corners node. And we'll see what it does.  You see, it adds a small face around the edge. If I change the radius, the size of this hair will change.  And I'll add a new face.  Perhaps we don't need such an ideal effect. We could additionally control or reduce this radius with noise.  I'll add a Noise node. And just to show what it does, I'll connect it to Base Color.  And now I'll add a new face.  You see, it adds a small face around the edge. And we'll see what it does.  And now I'll add a new face.  and now with this noise we can control the radius around the edges I want a high frequency  and a larger octave  and I do this quite often I connect these cards to the basic color just to understand  what they do and what is happening and now I connect to the radius  and I will also add fit range or I will add range just to reduce the effect  I will increase the contrast with the help of two upper sliders and see what effect appears,  only it is too strong  and now we have damaged edges  and what's great we didn't have to model anything here or somehow apply some  efforts everything turned out easily and simply it turned out like this effect  and so now when we have a noise node and noise appeared, let's use this noise as a  mask copy these two nodes these while I move to the side I will copy these two  and transfer here  and now I can take this color correction or sometimes you can create a new texture at all  and then add rgb and mix or mix rgb and now you can mix these two on the basis of noise  and again let's check the color first I will connect to the color  slightly change the range  and change the scale  and now we can mix this mask in a mix and we can change the color a little here  super and we get a more interesting surface  let's use it on the main brick layer to slightly diversify the texture  I'll take this noise and mix and go back to the light stone shader I'll put it here  and you need to add a new texture  I have a new texture with a brick layer let's make a render before  cam 1  copy the triplanar one and color correct because here too will have to be corrected  connect one and the second  here I try to dilute this repetition on the surface  and although I only have two textures, in general, they can be connected as much as you want  super  let's look at the mask itself, it seems to me too small, let's increase the scale  I want the white places to be exactly white so that we have a clean mask and connect back  now we have slightly diversified the texture  and use color correction  and so we got a light variation on the bricks, of course, it would be possible to choose a more suitable texture, but for demonstration, it will also go down  further you can do the same thing use the same mask with normal and roughness  now we understand how to work with masks, let's see what other masks can be useful in shading  one of the most useful notes of Arnold for shading is the utility node  and it has three outputs  in procedural shading I usually use these three outputs one of them is ambient occlusion  connect to rgb and let's check albedo  and color mode I will leave on color  and in shade mode I will choose ambient occlusion and what turns out can then be used to add dirt  and of course you can increase the roughness  you can change the distance and then you can also use the range node and additionally control this range  just keep in mind that this node is based on surfaces and shading, so it also takes into account  any normals if you connect them if I increase the contrast so that you understand  then we will start to have a brick layer here  so this is ambient occlusion let's reduce  also from here you can use the position  I will connect to the output g that is, this is y  I will choose flat and pi and now we have a position along the y axis here below 0 and above 1  and this is also very cool for creating dirt, such a drop turns out  or you can use it as a mask, that is, a mask based on height  or here you can switch to n, that is, normal  such a mask is very suitable for adding impact from the atmosphere, let's say one  side can become lighter, that is, we are here we are lighting the surface in the sun  and the last two procedural techniques that I want to show is using  curvature and dirt I will add a node of the corvich  here is the key  and look so we highlight the edges, let's switch to the second camera so it will be better visible  now based on this mask you can add dirt or damage to the edges or mix different materials  for mixing there is a mix shader node, but I only have one shader here,  but you can, for example, take the material at the bottom and paint the metal on top like another shader and then  mix these two and then with the help of this mask add the worn edges on the metal, but for now I  just want to show how to use this node in general in the node of the corvich we use the radius parameter  and thus we set this curvature  you can also adjust the spread  and multiply  multiply enhances or reduces the effect  and plus there is also threshold value threshold to limit the spread  with the help of this node you can add dirt here I will switch to concave  I will reset the value  and so far it turns out a homogeneous effect  you just need to adjust the radius more precisely  you can also add noise  while I connect to the main color just to see the effect and again increase the octaves  reduce the scale  and add a range node to enhance the contrast  and now I will connect to the radius  and I will have such an effect and with the help of noise I can control these dirt spots  and you can also control in the range node  super and so we discussed curvature discussed dirt world space  also talked about using noise with textures and also discussed damage to the edges and changes of this radius  so that we have not such perfect edges and finally let's see how it all looks in the final shader  and so let's show what exactly I used in the final shader let's look at it in a close-up  so that the effect is clearly visible  in fact, here are all the same principles that we discussed here we have a lot of dirt  but I got through the black, but it seems normal to me plus brick  texture that goes along these details  here we have a sweep node  so the bricks are as it should be at the joints there are no blurring  here we have bronze with grunge map that is, we slightly diversified it to a smaller scale  and in the lower part we also slightly diversified the main texture  here look at this part  we combine all this  then noise is added  it is based on the curvedness  then we add color correction to make the dirt darker this is just a darker version of the texture itself  then we use convex convex and here we add lighter edges  then we have a position that is based on the y, so we have darker at the bottom, lighter on top  and finally add grunge map, put it on top for the sharpness there is nothing  and at the end there is still a normal map  well, that's it  in general, this is how I usually approach the scene look dev, I usually set the camera  so that it is close enough so that when I work on textures and test them,  I can see well what is happening and then I work on the materials  if, for example, I understand that we will look at the camera from such a distance, then you need to make sure  that we can see the dirt and taking into account all these moments, I work on the materials  that's it, we'll finish on this, and in the next lesson we will set up the shaders of the leaves for the trees and the spread of the scene 
﻿1 So, now that we have collected the main parts of our scene and worked on the surface, let's create a vegetation that will be scattered around the city.  And here we will move a little further than in the previous course on creating the environment.  We return to our scene where we performed the look-dev, and here I have already loaded one of the trees with which we will work.  This tree was created in Speed 3 and on the course on creating the environment we dedicated this whole week.  If you need trees for your scene, they will also be included in the course materials.  And before starting to work, I changed the layout a little.  I switched to neutral HDRI so that we have lighting all over the scene and added a daytime setup for testing the surrounding light.  I will tell you more about it a little later.  And let's look at the setup of this tree.  Here is the bark that is separated from the leaves.  There is a bark on one side, here is a leaf on the other.  And there and there are our own shaders.  For the bark I have a simple tile texture.  There is also a normal map and a standard shader.  If we saw this tree closer in the scene, I would probably add a displacement, or perform a ZBrush sculpt, or even replace the whole trunk, that is, create it with photogrammetry.  But in this case, this is the closest distance from which we will look at it.  And not only at it, but also at other trees.  And therefore it is more important to me how they will look at medium and long distances.  So let's start shading the leaves and add different variations.  I will go to the Lips network.  Here I added a standard surface.  And if we check the albedo, then judging by the resources that we looked at, the color should be approximately 0.2-0.3.  And such a medium saturated green tone.  Let's check the render.  And you need to check that we connected with the correct shader.  Let's change.  And I will start the render again.  Yes, good.  While I change the roughness to 1, so as not to take into account the mirroring.  And I will also change the color of the trees.  And I will also change the color of the trees.  Yes, good.  While I change the roughness to 1, so as not to take into account the mirroring.  I will make it even more saturated and reduce the value.  And so far, the color on all the leaves is just homogeneous.  I want to vary them.  And here I can use the Color Jitter node.  It can be useful in various situations, and we will consider it a little later.  But it allows you to quickly randomize the main color.  I will choose the same green tone.  And now for each face, I can change the MinGain, MaxGain, and different color variations, as well as the saturation.  And then also change the initial value of the seed, also randomize.  This way I will have a color variation on all the leaves.  Only this tree has the problem that the leaf does not consist of one color, but of two.  Therefore, I want to add an attribute with a unique value for each leaf.  So that later we can use it in the shader to add color, randomization, and so on, without this node.  Let's delete it.  And so on.  And so on.  And so on.  And so on.  And so on.  And so on.  And so on.  And so on.  And so on.  For this grass valuableisin.  Now I also change necessary shadows in the project.  As we said, this attribute is related to the grid.  Each separate sheet will now have its own unique class attribute.  It will be on the points.  Next, I will add the attribute WAP, and this could be done on VEX, but now we will do WAPS, just for variety.  Let's see what we can do.  First, import the point attribute.  We look at the first input, because we pass it here.  And we are looking for the class attribute.  For now, I will connect to the color and check it.  Let's check.  We have a bunch of useless attributes. Let's delete them before moving on.  When you import a file into VEX, it has a lot of different attributes that are not really needed.  At least in this case.  And now, if we check, we will have a class attribute here. It goes from 0 to 75,000.  Next, I will add the fit range.  Only before that, I want to randomize the value. I will add random.  And I will add the value of the class attribute.  And I will add the value of the class attribute.  It will take the class attribute and randomize it in the range from 0 to 1.  I'll connect it here.  So, we will have a color attribute with a range from 0 to 75,000.  And if we run it through random, we will have a range in the end from 0 to 1.  And now, let's see the second input.  The range will be from 0 to 1.  And we will bring the fit range node to the target range.  To any range we need. We can increase the contrast or just leave it as it is.  I will not change it because I want to control it in the shader.  I will add bind export.  And I will call it leave ID.  And I will add the value of the class attribute.  Now we go back to the shader.  And here we need to import the attribute.  These nodes need to be looked for in the user data section.  We need the user data float node.  And let's check what class we exported, what type.  It is useful to check because sometimes you can confuse.  We exported float, so here we also import float.  And I will connect it to the color.  If I render now, it will just be a black and white map.  Only you need to specify the right leaf ID attribute.  And we can add the mix rgba.  We connect the attribute to the mix slot.  And then we can mix two colors.  And so the color changes from leaf to leaf.  You can also connect the ramp rgb.  I will connect the attribute to it.  And I will connect it at the output.  And here you can change the range.  And here you can change the range.  And here you can change the range.  And here you can change the range.  And here you can change the range.  It is very convenient that we can add such additional points.  And import other colors, for example, orange.  Look, it appears so accidentally on some sheets.  And in general, we were able to vary the leaves colors.  You can also use noise.  Add another mix.  Let's see what noise does.  Check the albedo.  And here you can see the color.  And here you can see the albedo.  And here you can see the color.  Check the albedo.  I will increase the contrast with the range node.  I will change the scale as we did before.  And I will connect to mix.  gradient ramp, but for now you can leave it like this. And here you can choose some more autumn shades.  In general, we get such beautiful color variations.  But of course, so far it does not look like a shader for leaves. We are missing its  main attribute, this is the light transmission.  To show what I'm talking about, let's switch to the sun or the day setup.  Switch to camera 2.  Also, as for this setup, I already said that you do not always need to turn on both the sun and the  sky in your lighting system. Sometimes it's just enough sky if you have the right tones.  Now we don't even have the sun in this setup, we only have the sky, and the sun is in HDRI.  So, my houdini flew out, I restored the wall. And let's find the sun.  And see how bright the sun is from this HDRI. Look, here it is. Because of this,  very sharp shadows are obtained. This is only from this sun. Switch to camera 1.  And let's look at the light transmission in the standard shader. Although this is not a course on shading,  but it is still useful to know that each object that we see in the frame in this scene reacts  to light in different ways. Some absorb more light, others reflect more, and the third,  for example, leaves, some amount of light can be missed.  And of course, the glass has transparency, for example, and there are refractive objects. This is already a  more complex light dissipation. There is also surface dissipation, for example,  in the skin, wax and liquid, but such a render, of course, requires a lot of resources. For simpler  objects such as leaves and paper, you just need to allow some light to be missed  in the scene. In Arnold, you need to turn on the Thin World tab. Let's turn it on.  And as soon as it is turned on, we can use the subsurface slider on the corresponding tab.  And we change this value and thus skip more or less light. I made 0.4-0.5. This will be  quite enough. Although this, of course, completely depends on the leaves themselves, what they are like with you.  Now it looks more like a real leaf, how the leaves react to light. And now you can  test with different lighting setups. For example, a daytime setup or a neutral one.  And then you can already adjust the light to get something close to the reference.  And you can also test with our shot lighting.  After the hud did not fly out, I added some more to this setup.  Color Correct node for the subsurface. Let me turn it off.  When you activate the subsurface, it automatically takes any of the colors selected here.  In this case, white. But we want to take the color of the leaf itself.  Therefore, we take the basic color here and connect it to the subsurface.  So far, it still turns out to be very dark.  Here you need to increase the exposure and even increase the saturation.  To try to keep the color of the leaf.  Super.  Well, now you can quickly check with the main lighting, that is, shot lighting.  And summarize.  So far we have only considered one tree.  In the next lesson, we will scatter them throughout the scene and start balancing.  We will add color variations so that the trees look beautiful at a distance.  So far, we have only considered one tree. 
﻿1   The last thing we need to consider in terms of scene assembly is how to add vegetation to the whole scene.  It is interesting to separate the middle plan from the background.  So, I opened our scene.  Here we have a city.  This is the main, installed city.  And then there are a few more buildings from the library that we placed manually.  They were created based on the setups that we considered in the first few weeks.  And I also started adding materials for these objects.  And built a few main or rather custom buildings.  And now I would like to add trees between these buildings.  And we need to make sure that the trees will not be installed where the buildings are.  And for this I have already prepared something.  I will go into this object.  Here we have transferred the basis or the land of the city.  Where we created it.  Let me show you.  I think you should be familiar with this.  This is the first part of the setup of the buildings.  Where we determined the main contours and the basic forms of the buildings.  Here I loaded the city back using Alembic.  The rest of the setup was simply removed.  So that there was no extra.  I will render this.  Now I will return to the node trees scatter.  In general, here I only have the contours of the buildings.  In the blast node, I remove those that I do not need.  And then on the left I have the shrink wrap node.  So we create a geometry that is not visible.  A geometry that will capture all the contours of the buildings.  Look, these are the original data.  And this is the shrink wrap.  That is, it just captures this whole area, all the buildings.  So it is on the left.  And on the right I take this basis.  And add an extrude.  And then I cut out the blast nodes from the shrink wrap result.  As a result, I have a surface on which I can scatter points for vegetation.  And now you can add a new node.  I will take the instance node.  This is a node for trees in the foreground.  Foreground.  And I will add a new node.  Inside we take the object merge.  And we transfer that ground.  And we take the node scatter and align.  And here, of course, we can control the number of points,  the coverage, the angles, the angle of rotation and so on.  I will reduce the number of points in scatter and align.  And I will add a new node.  And I will add a new node.  And I will add a new node.  And I will add a new node.  And I will reduce the number of points.  But first I want to increase the coverage.  So that we have the entire surface covered.  And now I will start to increase the mean and max radius.  The maximum angle is 360.  Everything else can be left as it is.  And in alignment we choose my y here.  In attributes I will remove the PScale scale.  Because I want to control it separately.  Now after scatter I will add the attribute create.  And here we will add, create the attribute PScale.  And for that value 1.2 and 0.8.  Now I will add Wrangle.  And let's vary objects that will be installed on the point.  And let's vary objects that will be installed on the point.  Create the instance attribute.  And we need to check what our tree is called.  Look, we have generic 0.1.2.  While I switch to the manual update.  In general, 0.1.2.  Therefore, here we write generic.  Lower quotation.  And that's it.  Now you need to create an random number.  First, create a new variable.  int rnd equal  mass instead of data.  As a surface value we will take a number of the bud.  Randomize  Since the range from one to zero we need to change  as a point.  It should be from zero to the number of instances  which we have in this scene. In this case, 3.  Now, if I turn on auto update again, we will check the table,  but let's export this variable as an attribute.  And now we have a value of 0.1.2 here.  Good. Here we want to add an integer to the string, but we cannot add it as it is.  We first need to transform the function I2A. It transforms the integer into the line.  And then we write the name of the attribute.  If we now check this attribute, we will have the right names that we need.  We need to export them as an attribute. We just leave the variable.  Great. So, we have configured the instance node and the pscale too. And let's see what we get.  And here we switch the method to fast point instancing.  I forgot to write the right path.  So, good. Now we have trees growing everywhere. I think there are too many of them.  Let's increase the maximum and minimum radius.  And the scale seems to be good, but I would have reduced it a little.  So. Okay, and let's check the render.  Great. And now we have trees among the buildings. And pay attention to how much memory is used.  Not all the scene is loaded yet, but still very little is used.  Great. So, good. We have trees in the city. Now let's add them in the background.  And there we will already vary their color, size, scale and type.  To make it look more interesting, we had more variations.  So, now we are looking at the hills in the background and look what I did.  I added such a main building and placed it among the trees.  Well, in general, the same step is used here. Nothing has changed.  Only now I want to add masks and thus determine in which places trees should grow.  Before we start, I want to show something.  We already get a very loaded scene.  I turned on the daytime setup so that it would be easier and more convenient for us.  But even in this case, because of the HDR in the background, we got a very loaded scene.  We can remove HDR and we will do it at the end, but then we will talk about it in more detail.  Now I will just highlight the Day Sky.  I will open the Contribution tab. Here I will reduce the input to zero from the camera.  And so we will only have what we see on the render.  Okay, now let's talk about masks.  I will hide everything else.  To start, before Scatter and the Line, I will add AttribWarp.  And inside we can create some masks, for example, a density mask.  First, I want to show the mask in height.  For this, of course, we use positions and take only the Y channel.  I will add FitRange and so we can control this range.  It is very convenient when you have, for example, a shoreline and you want to remove trees there.  In our case, it is a city, so we will not remove many trees along the edges.  You can also add places where there may be rivers.  This can be done with the amount of Voronov.  I will add a node and do the same.  Only for noise, we need the Multiply node.  Oh, no, sorry, not Multiply, but Subtract.  You need to subtract one distance from the other.  And if we connect further, we will see what we get.  Reduce frequency.  Like this.  Now the main thing is to select the appropriate range.  I will add FitRange.  Increase contrast.  And now to break these straight...  Now to change these lines a little so that they are not continuous before shifting the position into noise.  No, not this one.  We can add NTListNoise.  Increase amplitude.  And see what happens.  The height is, of course, too high.  You need to be lower.  And the higher the amplitude, the stronger we break these lines.  Good.  Only so far this range is not quite suitable for us.  We don't want the trees to grow only along these black lines.  We need to add a little more.  But now we can multiply them.  And at the end you need another FitRange to limit the range.  You can also add areas that will be drawn manually.  I will add AtriPaint.  AtriPaint.  Here the attribute is created by mask.  It's called Mask.  You can leave it like this.  Now I press Shift.  Sorry, Ctrl and the middle mouse button.  And so I change the size.  And I will paint some area.  Here I accidentally changed it to zero.  And now.  We can draw any mask.  Suppose we want to remove them in the middle part.  I will connect it to the second input.  And here we do the same.  We import the Attribute.  The first input.  Attribute Mask.  And let's check.  Is this actually Attribute?  Yes.  Yes, it seems to be Float.  That's right.  Mask.  Ah, it was the second input.  And we get this mask.  Next, we can invert the complement nodes.  And we also multiply.  Great.  And now we have such an area in the middle where there will be no trees.  So far, we have not done it very procedurally.  If we change the ground, everything will be ruined.  At least this is a drawn mask for sure.  What could we do instead of this?  We can take Object Merge.  And move the building that is in the center.  Here we need to select Into This Object.  And then we can move the Attribute.  Take the Attrib Transfer node.  And move it  between the ground and the building.  And I'll add another Attrib Create.  And I'll call it Mask.  On this side there should be a white color.  That is, a unit.  And on this side it's black.  That is, zero.  And now in the Transfer node we take the mask attribute.  Points.  Let's visualize it.  You can click on this gear, turn the menu.  Add a visualizer here and select the color.  Attribute Mask.  And now we will see how the transfer will be performed.  You can make it more obvious.  Well.  Now we even have such a drop.  And now let's take this instead of what we drew.  And we will have this dark spot in the middle again.  In general, judging by how the building is made, it is not entirely waterproof.  That is, it will be difficult to perform this transfer.  And there should be enough geometry for us to have a good mask.  But it will not work.  And now let's export the attribute here as density.  Bind export node.  And in the Scatter and Align node we switch to Scale by Attribute.  And take the density attribute.  Well.  And now we will see how the transfer will be performed.  And now we will see how the transfer will be performed.  And now we will see how the transfer will be performed.  And in addition, we can remove the  belonged contributing à等等 parameters.  So, hide all我覺得 Stella.  like this, well, and then add color variations  as for the variations, I want to add two levels again, firstly, color variations on  each tree and then color variations with separate patches  I will add another atripwop  and here let's add the rent node inside and connect it to the petin so we will create a random attribute  with values ​​from 0 to 1 for each point, then we pass it through the ramp as we did in the shader  just keep in mind that you do not need to change this inner gradient here nothing  changes no colors you need to go to the top level and work with this gradient  if we want to work inside this one needs to be copied  and now we are changing here and it will be updated to the top level  so let's choose a color for trees  something similar to what we did before  these colors will change from tree to tree  and you can some yellow or orange some more brown  it will be easier, for example, if you choose here a constant interpolation  like this  how will we have these orange additions here you can add as many colors as you want, that is,  variations, then you need to export  I will call 3 ID  and also create noise  here we also add ramp  so far they are called the same, they need to be renamed so that it can be different for what they are  this one I will call noise  here 3 and here at the top they will now have different names, I will copy this one  I will connect with what is inside  let's do the same  I will take green  but no, it was necessary to copy inside and insert from the outside  I confused  no, it didn't work out, okay, let me redo it  probably somewhere I made a mistake  but that's better  well, now we choose green  and here is such a yellow or orange  I will increase the contrast by moving these two points closer to each other  let's see  you need to play with cleanliness  and add another one to the color  and add another fit range so that it is more clear what is happening to them  maybe this is because the scene is so big, you need a very low value like this  so it will go down  so better  and you need to export  this one I will call noise id  and since this is a color, you need to select the type of vector and the same with this  and we could also export the gray mask and then correct it in the shader, too, as an option, but for now let's leave it like this  and now we go to the shader I will find trees  three leaves  and now again we take the user data only rgb because this is the color  and enter that attribute 3id  and 3 noise id  only let's check what I did right  so 3id 3 noise id yes  let's connect and see what happens  first 3id  2 image  1 image  and  look, each tree has its color  and if we go back to the gradient, we can change the color distribution here,  you can even add more variations, more colors,  and let's see what the result will be with noise ID,  yes, here already appeared such patches of the same color,  and now we need to combine all this,  and since we have colors here, you can take mix rgba,  connect one attribute and another,  and then we decide how much should be one and the other,  you can increase the variations between trees,  and to make it better visible, you can even increase the shader,  you can increase, for example, or reduce, weaken this last color,  so that we have such minor color variations,  and so the trees in the background will look more interesting,  I added another atripwop and I will add the second,  and I will take the same noise,  here you can make 0.8, and this value is higher 0.6, for example,  and 1 and 2,  and I will add another fit range,  I want to create a random value for each point,  I will take the point number, connect it to random and then fit range,  and now I have a random value for each point,  and I will add another value,  and this will be the base value,  and in the end I have variations between points,  and I will add this from above,  the values ​​will of course be too big,  let's go up and fix the viewport,  so that you can visualize it,  and here we will have a very nice viewport,  now we see instances,  I will add bind export, export as pscale,  and now we see what happens,  you can move these sliders,  and now we see what happens,  and now we see what happens,  and now we see what happens,  you can move these sliders,  and create patches with larger trees,  and create patches with larger trees,  so it turns out that now we are varying the size of the trees,  and it is also possible that we want to control the location of these copies,  we can take exactly the same setup,  let's call it pscale,  and copy it,  I will call this instance,  and here I no longer need randomization,  this part can be removed,  I will leave only noise,  and I don't need the previous range,  let's increase the contrast a bit,  and instead of pscale we are now exporting,  another attribute of the index, for example,  and what do we do with it next,  just so we can check it,  let's connect to the color,  so we will see what happens,  so we will see what happens,  I want to narrow the range, so here it will be 0, 0.  And then in Wrangler we write.  If the index attribute is less than 1, then we create this copy.  That is, we instantiate this object at these points.  In general, here it was necessary to have 0, 1.  And here more than 0, 1.  And we instantiate another object.  That is, so we can control where which objects will grow and also what  size they will be.  Let's turn this off.  I'll make a render and see what happens.  Great.  And now we have both size variations and variations of the copies themselves.  I think we are done with the sheet.  In the next lesson, we will continue to talk about lighting and rendering.  Let's see the final version of lighting this scene.  Then we will add various atmospheric effects,  analyze the creation of different passes and see what else we need to complete the  compositing of this scene. 
﻿1   Now, when everything is in place  buildings, foliage, mountains, lighting and shading  the last thing to do is add an AUV to the render  and also set the rendering parameters  So let's see what kind of scene we got  Here we have the main buildings  at least the main ones are those next to the camera  Here we have trees, roads, some grass  and here are the main buildings  Here is another building  Then another layout of the city behind the bridge  There is water  And we don't see some buildings that will appear only on the render  If I go inside here  then here on this side we have the flag display on zero  This is just to hide something in the viewport  and simplify the navigation on the scene  Then the flag render is enabled by Alembic  To do this, you just press the display flag with CTRL  and turn on the flag render on this node  And I set up not only this  I have several trees that are also hidden, but visible on the render  So it's very convenient  So let's move on to rendering  First I want to set up several groups for light sources  This is so that we can control the input of each element in the composition  To divide light sources in Arnold, we need to go to them ourselves  Here we have the sun and the sky  In the sky parameter, I entered the name of the group  Here I entered the name of the group  Here I entered the name of the group  You can call it whatever you want  The main thing is that you understand what it is  and that this name differs from other sources  If I had more sources and I wanted them to be in one group  I could write the same name of the group for everyone  and they would all be in one group when we render  So now to configure them in ROPS  I select the ROP node and add a new AUV here  We just write RGB, lower emphasis and the name of the light group  That is, this is the sun  And one more sky  We can then view them when rendering  But for now let's continue working with the settings in this node  For tests, I have a frame range from 1 to 400  And here I entered 10, that is, every 10th frame will be rendered  Now on the main tab  I have all the stars selected in Candidate Objects  And in Candidate Lights too  Of course, you can change this if you want to render only some selected objects  for tests, for example, but I'll leave it like this  And you also need to turn on this flag  Export Reference Materials  Since we work with cached objects, with Alembic  This guarantees that all objects with assigned materials will be saved  That is, these attributes will be saved  And what we indicated in the material node, these materials will then be assigned to the geometry during rendering  If you start rendering without turning on this flag  Then some objects and buildings will be white on the render  But as soon as you turn it back, all materials will be assigned as needed  So, that was the main tab  Also note that here in the camera field I have written $OS  That is, this expression returns the name of this node to me  Although this is not necessary, just at some point I did a lot of tests  Often duplicated these nodes and so it was a little faster  Well, now let's go back to the properties tab  And continue with AUV  In general, AUV is a random variable  These are additional channels that you can add to your render  And this will allow you to edit these channels in Compose  Change them, manage their inputs and how they affect the final image  Each of them separately  And this can save a lot of time during rendering  Because you can change different things, change the gain, the level  In general, anything these channels have  Or you can add something else, enhance or weaken  And at the same time not return to shaders or lighting or repeat all the rendering  So, we have set up Light Group  And now let's add a few distributed AUV in the rock node  I'll add another one  And in this menu I will select P, this is the position  And when we go to Composing, I'll show you how to apply some of these channels  So, this is P, there is also N for Normals  There is Diffuse Albedo  There is Specular Direct, Specular Indirect  You can also add Indirect Light  This is not direct lighting, Z, this is Z Depth Depth  Transmission Direct and Indirect  This is only for water, if I want to enhance the breakage  In general, you can add everything you want  For example, you can add SSS  Or if you have Volume Pass, you can add Volume Direct Indirect  But at the moment this is all I need  Also, looking at the objects and my render, it would be possible to divide the objects of the front, middle and rear plan  And add them all to this list of Candidate Objects separately  I can create a new Rope node and call it Background  And in the Main tab in Candidate Objects I can load only these objects of the rear plan  And then in Composing I can add them in layers  So, if I worked with separate parts of the scene, which I think need to be finalized  Or they need some additional samples  Or, let's say, I was waiting for some assets from another department  And I can continue rendering the rear plan, if I knew that it was already completed  And then I just rendered the front plan separately while waiting for the updates  But since I worked on this whole scene, I only need one Rope node  Or another option, if you have something on the front plan very close to the camera  You can blur this part in Composing  And the rendering of the depth of the sharpness is quite expensive  So most Composing programs offer plugins that allow you to add this after rendering  And again, if I used the depth of the sharpness here, I would divide this scene into layers  It would be easier  So, now on the properties tab  I still need to check that everything is set correctly  So, this is the path where the file is saved  And at the end of $f is just the frame number  In this case, it will be 97  If I perform the final renders, I need to turn off the camera resolution re-determination  When testing, you can leave it on  Next, AUV  And the last thing to do is to determine what rendering parameters we will consider final  The final result will be different for everyone  In practice, this is the moment when the noise level is reduced to the level that suits you  I saw how often a lot of time is spent in the empty, increasing the number of samples during rendering  Although this is not necessary  I also saw in the movies the final shots that would not interfere with additional samples  I will show you the samples  Arnold has AA samples on the sampling tab  This is smoothing  There is an adaptive threshold  And then a sample for each channel  And also the raid depth tab, which we will talk about later  In each scene, these parameters are, of course, set differently  And it depends on what objects and materials it consists of  For example, if I had a lot of reflected light, for example, in the interior  Then maybe I would need to make diffuse bounce  And they eliminate any noise from the reflected light  The specular reduces noise in glossy reflections, both direct and non-direct  And if I had a lot of water and liquids, then I would probably need to increase the transmission  And the increase in SSS will allow you to improve things like skin, for example, with surface dissipation  And volume and direct are for volumetric  Of course, you can just increase it all and we will have a pretty clean rendering  But it will take a lot of time  There are several steps that can be taken to make the rendering more effective  We have already discussed the moment of building the scene, how it is created in the render engine, how much time is required for this  And we have already been able to shorten this time by caching objects and using instancing everywhere where it is possible  And we also need to check the texture quality  Let's quickly return to the shopnet and see which of them is the most effective  Look, here the textures indicate the TX format files  During rendering, Arnold transforms the TX format textures  But if they are already generated, then you also save some time  I'll go back to the Rob again  And we have already seen the texture quality  I'll go back to the Rob again  To make the renders more effective, it is recommended to leave the AA samples at a fairly low level, but not too much  If this amount is very low, but you increase these samples for separate channels, then it will not make sense  Because a low general maximum will not allow you to achieve the desired effect  Let's leave the camera samples at a low level, 3 is quite enough  Because they act as a multiplier for these channel values  I usually leave it at 1  And I leave 3 for the camera  This is not much  Then we run the render and check each channel to see where we need to add additional samples  Sometimes it can be very obvious, let's say you have some lights or very noisy areas  But this scene is not particularly difficult, so I know what you can do  About 4, 4 minimum  And 8 maximum  And slightly reduce the adaptive threshold  This is the threshold of noise  And I would have already received a fairly clean render only with these settings  If you suddenly find that you have noise during rendering and you have turned on these AOVs  I would perform a local rendering and then looked through these channels and determined where this noise can come from  Sometimes it happens due to specular, sometimes due to volumetric  Therefore, you need to monitor the channels and increase the samples only where the noise is not present  And finally, I would increase the camera samples until you get a good render and you will not spend a lot of time on it  I will return 3 again and now let's look at the Ray Depth tab  We have already talked about it before  In large scenes, I would diffuse the image and increase the depth of field  And I would also increase the depth of field of the camera  In large scenes, I would diffuse the image and increase the depth of field of the camera  In large scenes, I would diffuse the image and increase the depth of field of the camera  This will increase the rendering time, but will help to make lighting a little more realistic  Especially in cities where there are many nearby buildings and a lot of vegetation  In this case, we need a little more light in the frame so that the scene is more realistic  The specular can be left at 1, but you may need to increase it if you have reflected objects located close to each other  And you want them to reflect each other  Transmission and transparency can be slightly higher, since the ray must penetrate through the surface  And sometimes through several missing and transparent surfaces  And then return back to the camera through these surfaces  Imagine that you have 3-4 pieces of glass opposite each other  And these rays should pass through them and return  In this case, there should be at least 8 of them  But I don't need so much, so I can reduce it  I don't have so many missing surfaces  The next tab is Motion Blur  I definitely want to turn it on  If you notice that there is noise in the corners, the only way to reduce it is to increase the camera's samples  Finally, before we look at the render  Actually, everything is fine, let's run the render and see the result  So, now we have the render, we can view different channels  Let's check the Light Groups  Here we have the Sky tab  And this is the Sun tab  In the Compose tab we can increase or decrease or even delete them if we want  In the Compose tab we can increase or decrease or even delete them if we want  Also, notice that there is some noise here  If we look at the channels  In order to do this, you need to hold down Shift and press the button on the top of the screen  So, we can check the channels and see what happens to them  In Transmission tab we have some noise  Most likely, we need to increase the number of samples  Let's look further  In the SSS tab, the trees are also a bit noisy  But I think it's not that bad  The camera's samples will handle this  Well, there is nothing to say about the depth  But it will be clearer when we switch to the Compose tab  If we remove the blue channel, it will be more visible  Like this  So, you can roughly understand how to use it in Compose to create a certain atmosphere  Next, we don't need to change the color of the trees  We can change the color of the trees by pressing the button on the top of the screen  And we can see the trees in the back  The samples of Transmission will handle this  Specular looks good  They are good  Position  And then Light Groups  That's all I need  And I'm very happy that there is no big amount of noise here  Except here  So, at the moment I decided to increase the number of samples only in Transmission  So, now we can set the final number of camera samples  And the noise level  And we can render  For the test, I will render one frame  I will see how much time it will take  We will see if we need to reduce the samples to reduce the rendering time  But judging by my previous tests, such settings are quite suitable for me  And now we only have to adjust the noise level  But before rendering, I would like to discuss the cryptomata 
﻿1   Cryptomates are widely used in production.  These are automatically created masks that can be very useful in compositing.  They help to separate objects or parts of the image for quick color correction or masking.  And they are very easy to configure in the Arnold's houdini.  When using cryptomates, we create an ID for an asset or material.  And to configure this, you need to add an attribute to the geometry.  And with the help of this attribute, we separate this object, we mark it in a special way.  And then we save the attribute in the render.  And we save the attribute in the render.  And we save the attribute in the render.  And then we save the attribute in the render.  So that later it can be used in compositing.  It is very easy to add these attributes.  Just at the end of the entire network, add a new Wrangle, a couple of new attributes.  Let's do this for trees, for example.  I'll add Wrangle.  And we need to call these attributes as clear as possible, so that you understand what they are for.  This is SString.  This name is called SString.  And we call it SString.  I'll call this generic 0.  I'll copy the same attribute, but I'll call it CryptAsset.  Now I'll take this Wrangle, copy it for other trees.  You need to do this for each object.  This is if you want to add these IDs to these objects.  Well, we created the attributes, generic 0, 1 and 2.  Now you need to add them to the render.  I'll add a new ShopeNet and Arnold's network, ShaderNetwork.  I'll call it Crypto.  Go inside.  Here I'll add a CryptoMat node.  And AUV output.  I'll connect.  And in the CryptoMat node, everything is already set up.  Look, here are the names of these attributes.  CryptoAsset, CryptoObject and Cryptomaterial.  That's how they should be called.  And on the CryptoMat Globals tab,  you need to turn off  Strip Material Namespaces.  And then your objects will be divided by the name of the materials.  And now you need to add attributes in the RobNode.  This is done on the AUVShaders tab.  Find this CryptoShader.  And now I'll add a new node.  And I'll call it Render.  So we have Day, Cam1, and let's look at the render.  So, the render is there, and in theory we should have CryptoPasses here.  And they are also added, like AUV.  And I'll add a new node.  I have one for the material, for the object and for the asset.  And if we check these channels,  we will have Cryptomaterial, CryptoObject and CryptoAsset.  Super!  In the next video we will move on to compositing,  and I will show you how to get access to these attributes, to these passes,  and how to configure them.  Thank you for watching! 
﻿1   To complete the course, let's take everything we have done and create a simple composition with all our passes.  This will not be a deep immersion in compositing.  For this, of course, a whole course would be required,  not one lesson.  But by the end of this lesson you will have a good idea of ​​the pipeline of compositing.  You will understand how the import of images is performed, how channels are divided, masks and cryptomates are created,  color correction and export are performed.  We have considered all this in detail in the course on creating environments and this week it will be like a continuation of the course.  For demonstration here I will use fusion in da vinci resolve.  Resolve is a very useful program, it contains almost everything you need to create composes.  Here you can create an image, add sound and export high-quality images, all this is free.  In general, I have been using fusion for almost 10 years professionally, I am more than comfortable and the quality suits me quite well.  But of course, the entire industry mainly uses nuke.  And if it were a course on compositing, then it would certainly be recorded in nuke.  Although I also worked professionally in nuke, but I like to work with fusion and it's great that this is a free program.  Fusion can be purchased as a separate program, but here in da vinci it also works well.  If you work with me, then you can download da vinci resolve, go to fusion,  activate, if you are more comfortable using nuke, then each of these steps that I will show will also be easily repeated there.  As at the lighting stage, the first thing I want to configure here is aces.  To get access to the color control system in the viewer panel.  We have two windows here, two viewers, first and second. First you need to load the image.  To do this, I use loader.  To get access to this tab menu, as in Houdini, you need to press ctrl space.  Open this menu.  Add loader.  And I will find my renders.  I will add a render to the file.  At the moment, I exported every tenth frame just for tests.  First, let's check that everything suits me, and then we export the whole sequence.  Here I have every tenth frame and I rendered about half of the animation.  From the beginning and until the moment when we reached the last frame.  I will select one file and the whole sequence will be loaded.  You can remove the connection.  Now, to load the image into the viewer, just drag it like this. You can press 1.  Or on this little point.  And the same in this viewer, you can press 2.  You can drag or press again.  And now when the image is loaded, we see that the color space is set incorrectly.  We open this menu and here we select color space view.lad.  Then edit.  Here we find the folder with OCIO.  Select ACES CG.  And output sRGB. And everything is ready. Now our view will be exactly the same as in Houdini.  So, I rendered every tenth frame to 150 frames.  As you can see, there is a time scale here, you can move around it.  But it is not long enough, only 115 frames.  To lengthen it, we press here, this is edit, edit the working area.  And here we take it and drag it like this.  And now we return to Fusion.  And now there are 288 frames.  I only need 150.  I'll return it back.  Like this.  Well, since I only have every tenth frame, you can click here with the right button.  When the frames will be skipped, if I turn it on, we will only see my frames.  Well, let's change it to 150 here too.  And now we return to the main menu.  And here we have a time scale.  And we will change it to 150.  It will simply change the number of frames we see here.  But this is the working range.  Now I will turn it on.  It will be played to the end and then return to the beginning.  Great.  So, let me tell you how to move in these viewports.  We panoramic with the middle mouse button.  And then we zoom in with the middle and left mouse button.  Before moving on, let's check again if this composition is set correctly.  Go to the Fusion menu.  Open the settings.  Frame format.  Here you need to check that we have a speed of 24 frames per second.  Frequency.  And here I have a size of 1920 by 803.  Although it is not necessary to change here, this can be changed in each node separately.  But if you change here, then all these settings will be standard for all nodes.  When you add a new node, there will be the same resolution.  Very convenient.  So, we imported our render.  Let's add the background sky.  I also want to switch this parameter to Hold Previous.  This is when there are no frames.  That is, when it finds a missed frame, like we have, since we have only rendered every tenth, we have many such frames.  It will show the previous one.  And now let's add the sky.  I will add another loader.  I downloaded this from the mappaint.org site.  If I drag these together, then it will add a merge.  It was possible to just create a merge and drag both, connect.  Well, you can do that too.  As a result, we have an orange connection.  This is the background background and the green is the front.  We need to change places.  I press 1 to load.  The sky is huge.  Here is 9K.  And here is 2K.  So, I will change it.  Also for 8K it was not strange.  Now, I will do the Buffet node.  This node isボーナンネートlinux  Evenеt takenv laughs  A small cat isricolour.  This node is былр ありас  pong  I will change the crop to 803. This is the size of our image.  And with transform I can move. Let's show.  The crop node returned us our previous resolution. And now you can use transform.  And here you can find the appropriate position. If anything, later it can be changed.  Let it be like this, for example.  When I work with the sky, and the sky is usually very important, I pay attention to the reflection.  And here, when I did rendering, I intentionally made this reflection, because I needed this bright spot in the hud.  And now I also combined the sky with this spot.  And here I want to save most of the silhouette of this main building, so that it does not close with clouds.  And the horizon should be where it really should be.  Because when you work with such a back plane, and you have such a angle, when the clouds are right above us, we get such a beautiful view in the distance.  And we see how the clouds change as they move away. They become smaller and thinner closer to the horizon.  This is what gives the image depth. I don't want to lose it.  So, we added the sky.  And so far it's just the background. If I turn it on now, I probably need to turn it on only here.  And as you can see, it does not move. It's just in the same place where it was.  We'll come back to this a little later.  So far, let's take a look at the methods of color correction.  The first question that arises is why? Why do we need color correction?  When we look at the references and at the color of the sky, which we added here and on our scene, it will become very interesting.  It will become obvious that our colors do not match.  We have a purple shade of sky and a yellowish-orange shade of the rays of the sun.  And I need my environment to reflect this.  To do this, I'll take the first loader and load our sky pass, i.e. light sky that we created.  We go to the format, open the list of channels and in RGB we choose red, green, blue.  Select the sky.  And we go to the color correction.  We go to the format, open the list of channels and in RGB we choose red, green, blue.  Select the sky, sky and sky.  R, G and B.  That is, from here we remove the sun, load the light from the sky, this is how it looks.  If you want to see only the light from the sun, you can copy.  And here we will remove the sun. R, G and B.  And now there is only the sun.  It's a little dark though.  To change this, you need to add color correction.  Since this is EXR, you can change the gain.  And so we see what the sun does, its contribution.  And now we will add the color correction.  And so we see what the sun does, its contribution.  To add back, you need to take the channel boolean node.  Here we combine these two images.  But I will not copy the sun, but add it.  It will be added from above.  Now we have the sun and we can change its contribution.  And so we see what the sun does.  A little effort.  But I also want to adjust the color range of the environment.  I want to make it more purple.  I have such a color circle here.  I can drag it like this.  Something like this.  And I need to return the sky so that you can check.  But it seems to me that it already matches more.  They match better.  We can skip and compare.  It seems to me that it is better.  So we used loader loaders.  We added several channels and corrected them.  But there is another very useful thing that we exported from Houdini.  It's cryptomates.  Now I look at the river.  And it seems to me that this part looks too bright.  And it distracts the attention from the main building.  And it distracts the attention from the main building.  Which is here at the top.  Which is here at the top.  But here in this part the image is more contrasting.  But here in this part the image is more contrasting.  But here in this part the image is more contrasting.  To reduce this contrast  I will add a cryptomate.  To have access to the cryptomate Fusion  First you need to install the reactor.  Reactor is a free library of plugins for Fusion.  Reactor is a free library of plugins for Fusion.  It is very easy to install.  You need to go to this link  And click on the page stickunderwater.com  And click on the page stickunderwater.com  Here is the page Getting Started with Reactor.  Here is the page Getting Started with Reactor.  This is the community that creates a reactor for Fusion.  I will add this link and share it with you.  Here you just need to load the script.  As soon as it is loaded.  And now just drag it here.  And now just drag it here.  After you downloaded it.  It asks if you want to install and run it.  Yes, you confirm.  Now you need to restart DaVinci Resolve.  Then go to Workspace, Scripts, Reactor.  Workspace, Scripts, Reactor.  And open Reactor.  Open.  And now you will have this library of plugins.  You can see what is here.  And now I need a cryptomate.  As soon as you select it.  Click on Install Install.  And you will have access to it.  Here will be a cryptomate node.  How does it work?  It reads your EXR.  Which you exported.  And allows you to create a mask.  Based on the data that is there.  Based on the data that is there.  I drag it here.  At first it will be difficult to see.  Because here we have such a chess texture.  You need to turn it off.  This is Checker Underlay.  And now we see the colors.  And now we select the cryptomate.  And move this manipulator.  Select some color and click Add.  And now only the river will be added to the cryptomate.  Now we are looking at the colors.  But I want to look at the masks.  Now I will add color correction.  And now I can reduce the gain only by the river.  Great.  And now it does not distract attention from the building.  As before.  Another type of mask is  Volume Mask.  To configure it, you need to add  a Volume Mask node.  I will copy this loader.  Because I want to import the position.  This is P.R, P.G  And P.B.  Now we have a position in the world.  Now we have a position in the world.  This is how this pass looks.  This is how this pass looks.  And I will also take this node.  And I will also take this node.  Next, Channel Boolean.  Add this position.  To this EXR.  I will connect as a background.  This as a foreground.  For RGB, I will choose the option  not to do anything.  I do not want to update these channels.  Instead, I want to update these additional ones.  Instead, I want to update these additional ones.  And add RGB.  And from this,  this position in the world.  To XYZ channels  additional, the original render.  For X, we select Red foreground.  For Y,  Green foreground.  For Z, Blue foreground.  And now I have everything set up so that  we take the original render.  Plus, XYZ channels  from the pass position we created.  Now you just need to connect to the Volume Mask.  And now if I load into this viewer,  here I can take this tool  and select  any area.  And change its size.  I switch to the sphere.  And see what happens.  So you can take any area  and use it as a mask.  Let's say we don't like this bright spot.  We can only darken this area.  The advantage of this method is that this mask is based on  positions in the world.  And it will not shift.  It will always stay where I was in this scene.  And now you can darken this part of the image.  So far, the settings are wrong.  First, you need to go through Bitmap,  select Luminance.  And you can move it anywhere.  Now I used it to darken this part of the image.  And now when you place it where you need it,  and then darken or lighten these areas,  you can do anything.  So, that was the Volume Mask.  What other masks are there?  There is also Paint Mask.  And this is the Mask of the World.  And this is the Mask of the World.  And there are still more masks.  There is also Paint Mask.  But I'll show you in the background.  Because we have mountains here  that rise too high.  If we want to paint some of them,  we can, of course, go to Photoshop and paint there.  Or you can do it here,  using the mask.  You need to add Mask Paint.  Add Transform.  And merge them together.  In the mask, you need to check  that we have the correct resolution,  like the original render.  So, go here.  And you also need to check  that 32-bit is always selected.  In the process of compositing,  you may have situations  when you have color stripes.  We will have the same.  Usually this happens  because of the 8-bit image.  So, I check that 32-bit is everywhere.  In this case, it is already set.  And here I will change to 154.  3867.  And here the same.  You need to check that there are also 32-bits.  Great.  So, now take Mask Paint  and paint some area  down here.  Let's see  what the mask looks like.  Let's set it up correctly.  If I don't turn off  Use Frame Format Settings,  I will always have  the previous resolution,  1920x1080.  Turn on the flag.  Great.  And now you can switch  to Controls tab.  Here you can draw, fill, wash,  fill in and so on.  And now I want to paint  this area down here.  It's easier when you see these mountains.  Paint the area.  Take Transform  and move down to the right.  And with this mask we will have  such a painted area.  Of course, it's better  to do it in Photoshop.  It would be better.  I just wanted to show  this Mask Paint node.  Let's just connect it here.  There is also Ellipse.  You can also do this  with the mask.  And here you can also  add some details.  You can also create  a mask like this.  And there is such a  multi-angle mask.  So you just create a curved bezier.  And here you can change Soft Edge  and thus create a soft  spad.  In general, these were the options  for working with masks.  These are not all nodes, but the most important of them.  Now let's see how to add depth.  ZDepth.  So far I will show the final result.  In general, I want to add depth.  We need to take our Path  ZDepth.  And here we find ZRGEB again.  I'll just add Bitmap,  because here I only need the blue channel.  And so far we will not see anything, because  these values in the world  are not the same.  And to be noticed this spad,  this depth,  here you need a higher value.  And here we need to add depth.  We also need to turn off the clip  Black, so that we can go below zero.  Because the lower the lower, the closer to us.  Now we need the background node.  Here it will be just a solid color.  Once again go to the settings, turn off  change to what we need  and check that the depth is 32 bits.  I'll connect it like a mask.  I'll drag these two outputs together to add Merge.  And now it's on top.  And so far black.  I want to have a color similar to the color of the sky.  I'll take a pipette and choose some color.  More suitable, closer to the horizon.  We have a slightly purple scene,  so let's choose a colder color.  And to remove it from the sky,  we already have a mask for this.  Because when adding any loader,  when you just create them,  it will immediately be with a mask.  So you can connect this mask channel.  Now it is only on these hills in the background.  Now you just need to choose the right color.  And so far black.  And so far black.  And also look at the horizon and the color of the sky.  And then of course ...  Oops!  And then you can in the Bitmap node  move this slider,  these two points,  and decide what effect you need,  how strong, where it will start  and where to end.  I want it to be far enough.  And so on.  Well, something like that.  And now you can reduce by changing the Blend node in the Merge node.  And you need to balance these two points  to get the desired coverage.  Okay, I'm fine so far.  We have such a light haze.  Okay, we are satisfied with the scenes.  Now let's see how to add camera effects.  The first is chromatic lighting.  The first is chromatic aberration.  It is quite easy to add.  Because we have already loaded the reactor.  We can open again.  And here you need to find XF PromoFuse.  You probably have to install  and restart Fusion.  Oh, no, I'm fine.  And now add ChromoFuse.  As a result, there will be a light  chromatic aberration in the corners of the frame.  I just want to add a little bit.  Because it is assumed that this is  a real camera.  And here it is very easy to overdo,  so it is best to add unnoticed.  You need to change the size.  And the smaller the effect,  the more obvious it will be.  Even 0.99 will be fine.  Even this is a lot.  And since we are scaling  RGB channels, you need to add a Transform node  and again increase the scale.  And here you can see the result.  And now we have a more realistic  chromatic aberration in the corners.  I think these mountains  can be made even darker.  They are still very beautiful.  And here you can see the result.  And here you can see the result.  And here you can see the result.  And here you can see the result.  Now I have to make these mountains even darker.  They are still too light.  The light will change.  And let's see where it comes from.  Yes, it seems to me so much better.  Here they are still a little bright.  I'll leave it like this.  Let's see what else can be done. I think you can add lens distortion.  Here you can see how much effect you need.  It all depends on what you want to achieve.  Let me tell you again. All these effects, chromatic aberration, lens distortion, grain.  When you work in a professional environment, all this information comes from the camera's data.  In most cases, you will be provided with it.  And when creating composes, many of these tasks will already be solved.  And you will have the most important thing to match the real camera.  But when there is no such thing, we simply imitate here.  Therefore, I try to add it all carefully, very unnoticeably.  And again, if it were some kind of final composition, not just a demonstration for the lesson,  I would look at real examples and try to do the same.  Now in lens distortion I will choose pf track. It will be easier to control.  I can make less, more.  But you can make it smaller a little.  It is necessary to simply create a light presence in the smartphone,  a point.  And I change the Depth of rank 2 Market Square Resolution.  We can reduce the size of the frame a little.  We just need to create a slight curve around the frame.  And again, the Transform node should return the same scale.  Usually, in a production pipeline, we would take this into account and immediately render with an over-scan,  so as not to lose the resolution that we had with the final render.  What else can you add? You can also add Glow.  We have such a bright area here, and this bright glow, this color should slightly affect the mountains or objects that are in the background.  And here we have the Glow tool.  And look what happens. It works pretty well right away.  I think you don't even need to add anything else there. Maybe reduce the effect a little.  You can also add Grain.  There is also a Film Grain node for this.  But you need a very light effect.  By default, it turns out to be too strong, so I want to reduce it.  And here we have the Glow tool.  At the end, I add black stripes so that we have HD resolution again.  This will be the background, this is the front view.  Here, the background is already black, and we can add a little more.  And here we have the Glow tool.  And here we have the Glow tool.  At the end, I add a little more.  And here we have the Glow tool.  And here we have the Glow tool.  And here we have the Glow tool.  Before this, you can add another Camera effect.  To imitate light hitting the lens.  This is another effect that can be easily overlaid.  So we need to make it very thin.  This is the background.  This is the foreground.  And here we have a mask.  This is the mask input, if I'm not mistaken.  I change the scale.  And I increase the Soft Edge.  And I invert.  Now we have such a drop.  Probably too much.  In the Merge node, I reduce by changing the Blend.  And here we have the Glow tool.  And here we have the Glow tool.  Great.  And before we move on to the final stage,  let's make sure that the sky does not shift.  To fix this, we need to go to Fusion, to the 3D scene.  First, you need to connect the camera.  because for the rendering of the sky as a backplate we need a camera  we will render the sky first we export the camera from the houdini  here we go to the file export alembic here we select the range and select only the camera from the list  select the path where the file will be saved I save in the same place as the heap file  I always add the point abc because it does not add itself because of this there may be a problem  so camera version 4. abc  now we have returned to fusion now we go to fusion import import alembic scene and find the camera  and here you only need to select the camera nothing else is needed ok so let's find it  it looks like it's somewhere far  to find it I press ctrl f and write 3d  and here it is  I press ctrl x  now I will return to our working area I will insert here so now I have a camera  if I drag the transform 3d into the viewer window, then we will automatically switch to  three-dimensional working space and since we took it from the houdini, it is 100 times  more than necessary, but I will reduce the transform to 0.01  if I hide everything else in the viewport and I will scroll it like this, we will see the animation of the camera  and now I want to take this image plane and transfer it here in 3d we take the image plane 3d we connect it here  then we take the merge 3d to combine them  and somewhere there should be a plane  now to remove the parallax in the sky we need it to be as big as possible and as far as possible from us  in the image plane we go to the transform tab and make a huge one, let's start with 10,000  and move it from the camera to the background  I think you can even make even more  here do as much as possible so that there is no parallax at all  and now to look at it I will add a render 3d  and connect the merge to it, this is how the render looks  and again we need 1920 by 803 and 32 bits  so now when all this is set up, we must place it correctly in 3d,  you can turn the camera  and connect instead of our two-dimensional sky  transform and crop we no longer need here you can turn off  and now we have such a render  let's place it correctly  perfectly these mountains in the background still stand out, but too light, I will return to the original render  and add another cryptomat  it's just to highlight these mountains in the background  and with the color correction node we darken them a little  connect like a mask  it seems to me already better  but here it became too bright probably because of the sun that we added again  so it's better  and then I'll add a haze so that it closes all this  it went in and in the middle  super  in general, as I said, if it were some kind of final final composition, I would of course try here,  but so far for the lesson it turned out very well, I would say that this is a slab comp, such a  quick composition so that you can at first appreciate how everything combines with each other  and that's it, we'll finish it  now we will save all this and then we will import again and see what we have  added a saver  again  so we added a saver and so you can save the image from the sequence  and you need to check that I have  in all the loaders here hold previous is selected for missing files  just so that we do not have any errors when we start  so everything is fine here  now we indicate the path  and in the name of the file we will have the name of the render and the point and xr  I will leave this underline after which nothing will be  tested version 1 lower underline and the point and xr as a result after this underline the frame  range will be added and now to save we go fusion and render all savers  just check that there are 32 bits here, yes, fine, fusion render all savers  so I have something happened and the render has not finished, let's try to find a reason  and here I have some kind of saver accidentally added  let's try again  and everything is ready now again take the loader loader  and return back  the main thing is to choose the right one  make the window larger  so let's look through only the tenth frame and turn on  and in theory now is the moment when I evaluated what happened I like it looks great and  then I would return in the hudin I rendered the whole sequence returned here and finished the composition  and that's it we are finishing the course thank you for being with me for all these weeks  this journey was long but I hope that throughout this course you have learned a lot and are happy with the  results thank you see you maybe see you in another course 