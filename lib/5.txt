1   Now we have a layout and a camera, and we know which areas we are planning to work on.  Therefore, it is time to consider the ways to fill our scene.  This whole week is dedicated to the creation of the city and its filling.  There are many ways to fill the city. Some of them are easier to control, and some are more effective.  But we cannot say that one solution is always suitable.  In the end, it will most likely be a combination of various methods.  In the first half of the week, we will start with the simplest solution of instantiation and scattering.  This is the most effective way to create a scene.  But it is not the easiest to control, so we will work on making it more convenient.  The second half is dedicated to procedural setup.  That is, we move from the building to the creation of the city quarter, and then to a higher level.  We will discuss the whole city.  And add roads.  And in the end we will tell you how to make the scene as effective as possible, depending on what solution we choose.  Let's start with the first lesson.  The first lesson 
﻿1   As I said, this week will be dedicated to filling our scene and different approaches to this, depending on the needs of something.  In the first approach, we deal with points and instances. I think it is worth explaining the theory that lies at the heart of this approach.  Most students and, I think, all artists will be familiar with the rendering stage.  But if you have not worked in the effects department, lighting, rendering or compositing in production, then you may not be familiar with how complex the rendering of the voluminous scene can be.  As artists in the environment, and especially as hired employees, we cannot control much.  We do not take responsibility for the computing power or number of computers of the farm, for the final resolution or final rendering setup.  But we are responsible for our environment and, as a consequence, for how easy it is to process and render it.  So here we are just discussing the instance.  So, for example, I took such a small scene.  And within this scene, it turns out that we copied this building a thousand times.  Well, with enough variation, it would look great. Now, of course, it's not like that, but just imagine that this is our final scene.  Instead of just copying this building a thousand times and moving it, we can make it much more effective.  In this scenario, we created a thousand copies of the same building.  And before the rendering starts, the rendering engine must create, build the scene and load the geometry.  This means that we create one single image.  And this, in the end, is quite a lot of load.  Instancing solves this problem.  It allows you to load this building once and then create 999 of its instances, that is, copies.  And here we will have one building with the indication of its position in the scene.  And another 999 positions on which we then copy this building.  And this can be done in different ways, but most often in Houdini, artists around use point instancing.  We have a building that we want to copy, but we still need positions where we will copy it, where we will put the images.  And here we will have a building with the same position.  We have a building that we want to copy, but we still need positions where we will copy it, where there will be instances.  Points can be scattered throughout the scene and then installed on them.  And at points can contain not only information about the position, but also orientation, scale, color, material, or any other attribute that you need to change the copies.  Let's take a look at such a setup as an example.  Before that, we have already considered copying to certain points with the Copy to Points node, for example, when we copied windows and doors.  But maybe here we just want to create some kind of coating or fill in the whole scene, and not copy to specific positions.  To create points on the surface, Houdini has a Scatter node. It distributes points on the surface, as you can see here.  And here you indicate how many points you need, Force Total Count and Max Point Limit.  And you can also control their distribution by changing Relaxation, Relax Iterations.  And very often we create a density attribute for the placement of these points.  To do this, you can use the Paint node.  As a result, the points will be scattered only on the painted areas.  I'll add the Paint node.  I'll press Enter in the viewport to activate the node.  And I'll increase the brush.  Let's paint some area.  Let's say like this.  So far, this mask is called just a mask.  I can call it density. You can call it whatever you want.  And then in the Scatter node we turn on this density attribute.  Yes, probably because I changed the name, I will have to repaint it.  Here.  And as a result, the points are concentrated in this area.  Another way to create density and variations is to use AtripWop.  We have already briefly explained what AtripWop is for.  This is just one of the examples of its use.  Let's see how it works.  First, I will increase the density of this initial grid.  With the help of the Subdivide node.  This is because when we draw a mask, it is based on points.  Therefore, we must have a fairly dense grid so that there is a good resolution of the mask.  And now we go to AtripWop and create an A-A Noise here.  I will connect the position and connect it to the color at the output.  And see what happens.  But let me change the frequency.  The less the frequency, the greater the noise scale.  I just needed to hide the original surface in the viewport.  And now, if we check the data table,  we have values ​​from 0.3 to minus 0.3.  Next, I will add a FitRange to change the range.  And this is what you have to do always when we use the noise.  I need to change the noise.  I need minus 0.5 and 0.5.  And the target from 0 to 1.  And look, it has changed in the end.  Okay, after changing the range, I will add another FitRange.  And so we can increase the contrast.  And so far we have connected with the color, but instead you can take the BindExport node.  And save it as a Density attribute.  We have a new Density attribute again,  which saved what we did here.  And now we will add a new layer.  And now we connect with the scatter.  Our points will be concentrated in these areas.  It was such a very short review, but I still wanted to say about it now,  because we will be doing this all the time.  I will turn off the density.  And now let's move on to the Copy node,  because it is here that the instancing is performed.  So I added CopyToPoints.  And here we see the flag Pack and Instance.  What is a pack? We will discuss the package in another video.  And for now, if we will turn it on and off,  then we can check the difference in the output data.  Let's see what will change.  For now, I will change the scatter to one building.  I will turn off Pack and Instance.  Now you can perform rendering.  And if we follow the memory and time,  then at the end we will roughly understand how much we spent.  It turned out 380 MB.  If I turn on Pack and Instance, we will get about the same.  Let me restart it again.  It will be almost the same, because we have one object again.  And it doesn't matter if it was instanced or it's just a real object,  it still needs to be loaded into memory.  If we increase the number to 200 and I turn off Pack and Instance,  we will have 200 buildings.  And you will see the difference now.  And this is real speed. I don't speed up or slow down anything.  As you can see, it takes much more time.  Of course, we have much more objects here,  so it takes some time to run the render.  I think you already understand how much time it takes.  And the memory took about 1640-1635.  So, again, it was in real time.  And now I will turn on Pack and Instance again.  And the rendering will start almost instantly.  And notice that we got about the same amount of MB.  Although there are so many buildings here,  that is, in theory, the memory should be used much more.  But it turned out almost the same as with one instance at the beginning.  Well, in general, I wanted to briefly tell you what instancing is  and how it happens in Houdini.  And then we will consider the ways of control and manipulation of these points. 
 Translated by the club.  So, we discussed the basics of scattering.  Now let's go further and consider other ways of manipulating points and their attributes.  Until now, in our setups, we used the CopyToPoints node.  But in general, there is a very similar node that gives a similar result.  This is the instance node.  In the early stages of the implementation of Arnold and Redshift in Houdini, it was usually recommended to use the instance node.  And these nodes are very similar, and it cannot be said that some has more pluses or more minuses.  It simplifies the loading of instances a little, and therefore I prefer this node for the final scene assembly.  Let's consider our setup and try to insert the instance node here.  And in this case, we only need these right nodes.  Copy.  Add the instance node.  And we will add the instance node.  I will remove this Add and insert those nodes.  Now we go to the upper level and see what parameters are here.  I want to go to the instance tab and discuss the variations.  So, in this tab we have the parameter InstaSubject.  Here you need to indicate the path to the object that we want to instance.  We indicate the geometry if we need only one option.  But instead of using this parameter, I want to install this path inside the node so that it can be changed for each node.  And while we are at this level, here in Point Instancing I will choose the Fast Point Instancing option.  Since we plan to vary objects and materials, this is the most effective option.  The second Full Point Instancing option has more possibilities, but it can be much less.  And let's go inside.  Now I will add Wrangle here.  This is how we will define the variations.  And now we will add the variable to the node.  This is how we will define the variations.  We will do this using the instance attribute.  This is a string, that is, an instance dog.  And in the instance node itself, instead of the path to the instance, the node will look for the instance dog attribute.  And it is equal to the path to our object.  And now we will add the variable to the node.  Let me check what it was called.  And in the end, the buildings were copied to these points.  Great.  But of course we need different variations.  Therefore, we need to add a couple more buildings.  I just copy them.  And I will find my library with buildings, which I created for this course.  I used the same setup as I showed in previous lessons.  This is one option.  And I will find another one. So we will have three.  And to make it easier, I will add the lower brackets 0, 1 and 2.  And now we will return to the instance node.  Let's go inside.  Now in this wrangle, instead of copying one building, we use the point number and the division by the module.  That is, the percentage sign.  Now I have a string here, so I cannot add an integer to it.  First, you need to convert the integer into a string using the function i2a.  We add the point number.  And module 3.  That is, we will have values 0, 1, 2.  And the function i2a.  So we added the point number to this line.  So far nothing has happened because we are inside the node.  If I check the table, we have the value 0, 1, 2.  And the point number is 0, 1, 2.  If I check the table, we have the value 0, 1, 2.  I would like to add the lower brackets. I will add here.  This is how it works.  If I did not add the function i2a, then, as you understand, it would not work.  Because there should be a line plus a line. We cannot add an integer to the line.  Super. And now we go up.  And now we have these variations.  Let's make it easier for us.  I will open the scene here below.  And fix it.  Now when I go inside, I see the points here, and here I see the result.  And now let's check the orientation.  Now instead of scatter nodes, let's add scatter and align.  Of course, initially we have too many of them.  But the main advantage of scatter is that it is not a single line.  And the advantage of scatter and align nodes is that we have access to orientation here.  And I usually set the coverage to 1.  And then I change the minimum and maximum radius and thus distribute the points.  And notice that when I do this, the scale of the building will also change.  To prevent this, you need to go to the attributes and disable the radius attribute.  So the size of the building will not change.  But we can change the min and max and thus control the distance between the points.  As we have already said, we can control this distribution using density.  We switch to byDensity and turn on this attribute.  I don't have it yet, but we could take paint, as we did before, and control it in the same way.  The main thing is to name it exactly the same as here.  In this case, density.  I will return it again to bySize.  And let's look at the orientation parameters.  Here we have the opportunity to set the minimum and maximum angle of rotation.  We can shift the cone angle, that is, in other axes.  You can generally shift the entire angle of rotation.  And we can round to multiple values.  I would like to change it to 90 degrees.  We turn the points only 90 degrees.  Multiply by 90.  And before that, I used AtripRandomize to randomize the color.  In the same way, you can randomize the PScale attribute.  And now we can change the color.  And we can change the color.  Super!  And before we continue, I want to mention one more feature of the Scatter Underline node.  If I go back to the grid and connect Mountain, the geometry will be uneven.  And now I will come back here and look.  They all tilt to the left and right.  From the grid relief.  Let me even make it clear.  That is, their direction coincides with the direction of the normal grid.  In some cases it is good, and in some it is not.  Especially when you place a building.  Therefore, here we need the Alignment section.  We turn on blending with the y axis.  And in the end they will repeat the relief of the geometry, but at the same time they will all be directed up by y.  Super!  Let me cancel all this.  It is also possible that in some situations you need some kind of strict pattern when distributing objects.  In this case, it is better to just start with the grid.  That is, we get such a predictable pattern.  And the number of points now depends on the number of rows and columns of the grid.  I want to reduce their number.  I will make such a denser grid.  I don't do this in the final scene.  But I used this method before and it is quite working.  I just want to delete some rows and points.  And for this I will take the Delete node.  Or you can use the attribute that was created before this.  Here I will just take the Delete node.  And Bounding Box.  Here we will have a road.  The advantage of the Scatter and Align nodes is that we had the opportunity to randomize the rotation and fix it with an angle of 90 degrees.  But in the end, all the buildings are oriented the same.  Let's continue to vary the rotation using the same method.  I will add a Vex.  I will add Wrangle.  Here we will work on orientation.  The Orient attribute is the most stable way to describe the rotation of points.  The earlier we start using it, the better.  So let's start now.  Orient is very similar to the PScale attribute.  In the sense that this is an already pre-installed attribute that can be manipulated and changed.  Orient is a quaternion.  That is, a dog Orient.  That is, this is a four-dimensional vector.  Why am I talking about this?  The Orient attribute can be difficult for beginners.  It can be difficult to understand.  But when we describe it as a quaternion and read the reference of the Houdini on the quaternions, it will become clearer.  Let me open the reference.  And here we are looking for a quaternion.  We need this second one.  The Quaternion function creates a vector 4 that is a quaternion.  That is, it is needed to describe rotation.  We write Orient is equal to the quaternion.  The first argument is the orientation.  That is, we write Orient is equal to the quaternion.  And the first argument is the angle.  So far, let it be zero.  And the second is the axis.  Let's say 0 and 1, 0.  Let's take it away for now.  And if we now change the angle, the building will rotate.  And if we change the axis, they will rotate around another axis.  Here I will return the y-axis again.  And again we will change the angle.  Note that between the number that we enter here and what happens to the buildings, there is no obvious connection.  And if we read the reference again, we will see that the angle here is determined, described in radians.  Let me briefly explain what we need to know at the moment.  Radians are associated with the radius of the circumference.  And the quaternion function that we use here is expected to be in radians.  But we can use another simple function to convert degrees into radians.  This is the radians function.  I will add it here, I will write it down.  And now if we change the angle, they will rotate as we expect.  It will be exactly 45 degrees.  Well, to simplify the task, let's introduce a couple of new variables.  We will add float for the angle, angle for now let it be 20, and vector for the axis axis.  This will be the y-axis.  And now we pass these variables to the function.  There is not enough  to make the same rotation as in the scatter and align node.  But we still have no randomization for each point and no steps of 90 degrees.  We have already talked to you about the separation by the module, we can use it here.  The angle can be equal to 5, the module 5 and multiply by 90.  And so that we can check the value in the table of data, let's make it an attribute.  And again call here.  And now if we check the table, we will see this angle.  It changes from 0 to 360 degrees.  And so far this number float, you can add i to make it an integer.  And it turns out what we need.  Only they are rotated in rows.  I will add the sort node.  We need to randomize the order of the points.  Great.  And before we go further, I want to tell you about another problem that we can sometimes encounter.  When we install something on the point, one of the ways to add some randomness is the point jitter.  Also a very useful node, let's add it here.  I will increase the scale.  As a result, it works like a mountain node.  Because of this, the points also rise along the y-axis.  We could, for example, reduce the scale by a little.  And so we can see that the point is not so high.  And so far the points are rising along the y-axis.  We could, for example, reduce the scale by y to 0.  That is, the points will shift only by x and z.  But if we take, for example, such a deformed plane.  And while I switch to scatter underline.  Here we see that many points begin to rise above the surface, to go under it.  And so on.  And since we will work exactly like this, let me show you how to fix it.  The easiest way to take these points.  And project back to the plane.  RAY node.  And so on.  On the right we connect the geometry to which we project.  And on the left are the points.  Here I change to a vector.  And the average value should be minus 1.  And so all the points will move down until they meet the surface.  Also in this RAY node there is one useful attribute.  More precisely, this is a group.  RAY HEAT GROUP.  I'll just call it HEAT.  And if we add the BLAST node further.  And we can say that we need to remove everything that did not hit the surface.  But only from this HEAT group.  It turns out that now we can both randomize the points positions.  And also remove the point that did not hit the surface.  I don't know if this will be useful to you or not, but I use it quite often.  In the next video we will consider other ways to distribute these buildings. 
﻿1   The process of working on the city can arise from the moment when you need to create a certain layout in some parts of the environment.  Perhaps they are important for something or because we have some new idea.  There are many ways to do this, and you can balance the effectiveness of the procedure and manual work if you need a specific layout.  Some methods can be difficult, but it is good to know that there are different options.  If we take our finished setup, then here we can easily take any of the points on which we have installed these buildings and move them.  For this, you just need the edit node.  I will divide the window again.  And I will fix this viewport.  Now we go to the instance node.  I can take any of the points and just move them.  And I can move the instance somewhere.  Let's say I'm shooting from the camera and I have a building on the way.  Then you can just move it to another place.  And you can also rotate them.  If we don't like the orientation, we can change it.  This was the first way to make changes to the layout.  But what if we don't like this particular example of the building?  What if we want to add something else here?  We can do this on Vex, as we did before.  I will add Wrangle.  And we can write sSobakaInstance equal to some particular example of the scene.  Let's say the building is 0.  If I do this, then every building will be replaced by a 0.  But we only need this point.  We need to find its number.  It's 50.  And we write 50 here.  And now the example will change only at this point.  And finally, there is an add node.  Let's make some space.  I will add Merge.  And add node.  It just creates a point.  It has very useful functions, which we will talk about a little later.  But now we just need it to create one point.  We create one point and we can move it.  This means that the building is already in the same place.  Let's say we don't want to change the current layout.  We just need additional points.  And so you can achieve a good balance between the ability to add something new to the scene,  change something inside the scene.  And at the same time you still use the instance node.  So you still have this efficiency.  When you work on the layout, you can add a new building.  In many cities, especially European ones, the location of buildings depends on the roads.  And they are most often accidentally or intentionally curved.  And we can arrange the building in several ways.  For example, we can make a curve in the middle of the road.  And we can arrange the building in several ways.  The first way is to use a curved bezier.  It's similar to what we did on the first week.  I'll hide it all.  Add a new instance node.  I'll choose fast point instancing.  And for now I'll take building 0.  And inside I'll create a curved bezier.  I'll hide it for now.  Add a new instance node.  And create a curve.  And I often do it in the form of a curve from above, so that the curve is exactly on the ground.  Then add a resample.  And in it we can already decide how many buildings we need.  And finally I'll add an Orient node.  To correct the orientation.  Just be careful here, sometimes the curve can be reversed.  You can fix it by highlighting all the points on the curved bezier.  And by turning them, we highlight these points and press Reverse.  Or you can add a reverse node at the end.  And we can add a curve.  That was one of the ways to create a curved bezier.  But here you have limited options.  So another way is to take a Draw Curve node.  So we add a Draw Curve.  And we can add a ground.  In this case it's just a flat grid, but we still add it here.  And here we project on the geometry.  Now we start drawing.  And by pressing Ctrl-Shift you can increase the size.  So we draw a curve along this line.  And we can add a curve.  And by pressing Ctrl-Shift you can increase the size.  So we draw a curve along this plane.  Then we apply Resample.  And now we use this curve.  But again, we need to turn it.  I'll add a Reverse node.  I'll do it before Resample.  Like this.  And this way we can draw several streets.  I'll divide this window by two again.  And I'll fix the top view.  Now I'll go to the instance node.  I'll go back to the Draw Curve node.  And I'll start drawing some streets.  And here we go.  Very cool.  And of course, here you can use some uneven relief grids as a ground.  But the buildings will still be correctly located on this grid.  But there will be one problem.  How to add random orientation to the curve later?  For example, we want to keep the main direction of the curve normal.  But we want to add some additional turns.  You can do this on Vex, but you will use Quaternion.  I'll open the Quaternion reference again.  Then I'll check.  Still nothing follows.  No Presents.  Still nothing tells me.  So, I'll sak you with my dick, photos can Battly 핏  But I must say that there are some different advantages to action drawing and making of the world voice Base.  And I'm thinking of painting.  and look here in this first option here we just have rotations and here we need a three-dimensional matrix  let's create this matrix I will only remove the extra curves we will not complicate  and add the orientation that we have already created this is orient  if I turn on the orient node we will get a random orientation but in the end we will lose the normal curve  to return the normals we just need the make transform function  in this function we pass the normals and y and one bracket is missing  and the attribute  so we returned our orientation but now we want to add some additional  rotation or more precisely we want to multiply it we already have the necessary information but instead  of using the orient attribute we will create a new variable type vector 4 we already said that  the quadrillion is just a vector 4 and use the qmulti play function that is the quadrillion multiply  I will return as it was  copy this orient  and create a new vector 4  I will call the rotate  it looks like what we did before  we pass the angle and the up vector now we have a new four-dimensional vector  rotate the same as the one we had before we take all this and create an orientation  that is orient is equal to qmulti play  and multiply the existing orient and rotate  and of course the angle can be any just we had it equal to 90 degrees depending on the  number of points so we returned this random turn to 90 degrees and at the same time we saved the orientation of the curve  and to make it even more convenient we could add the initial value to the number of points  that is, we write plus chai channel it will be a new channel type integer call it seed  you also need to take in brackets so that this function is performed first and now we can  change seed and also influence the result and at the end we can also add an additional  turn to this corner at the end we will also add but another channel  again integer  I will call extra mouth  and two brackets here there were not enough brackets and we have an additional rotation here you can also add  and the initial value of the seed is very cool and this is a rather reliable  setup you can do a lot of interesting  so the next step is what else can be done with this we can take this whole setup and create a street  we already have a curve but then we can create a road sidewalks buildings and for example  some lanterns  let's not have everything in one place we will transfer this initial curve here this  setup to a new node geometry I will leave here resample but add object merge  copy all this add a new node geometry  here we will have a road  and now here in object merge we take this result  and we will have the same great this while I will delete  so great and let's go back to the road, actually I don't have enough resample, let's add it too  so now we need to take this curve add thickness highlight its edges and use them  as a new curve on which we will later install this can be done in several ways  you can copy the line to this existing curve horizontal line with two  points and then copy it along the curve but you can make it even easier I will add a sweep node  I will choose a ribbon and type columns  so I will only have a curve without geometry now I will increase the width  and we get something like a street  you can add another resample after that if you want to adjust the distance so that it is more even  so we figured out the creations  to create a road we need another sweep node I will connect but this time we need  geometry so again we choose a ribbon  I will add here on the place of the output I will call out now back to the instance node here in object merge we will take this node out  now whatever I do here in the instance node will be transferred what comes out of this  node out and now in the second node sweep I will increase the width of the columns less and see what  happens next we just need a poly extrude to slightly raise  like this  enough just a little  so we have a problem with the placement of the buildings, they go beyond the edges of the sidewalk, you need to remove the initial and final points,  this again needs to be done with wrangle, but since we have two curves, we will do this with the  forage cycle, I will add forage connected piece  and now we take wrangle and create a new variable I will call lp  and we take the number of points minus one  let those who are not familiar with vex I will explain what is happening here I create a new  variable I call it lp it is obvious that when it is created it will be empty then I take the total  number of points here I will turn on the number of points I will return here this curve has points from 0 to 20, that is,  we will return 5 to us 21 if I click the middle button you will see that it says 21 points, that is, from 0 to 20  21 points I want to remove one and so I get the total number of points 21 minus 1 is 20 then I  want to remove the initial and final points so we write remove point 0 is the input in which the geometry  and then the point that I want to remove I always delete lp this is the last point  then we do the same but we remove the first point which is always with number 0  and as you can see, there are fewer of them because we removed the first last point  and now we get what we wanted the sidewalk is wider than the building so well,  what else can you do here we can fix these sharp edges we can round them and you can even add borders  along this sidewalk  but I think I have already explained enough here and you can do everything else yourself  as a result, we got such a street we can return to the node draw curve and thus create another street  anywhere and any form  everything I think we will end with scattering in the next video we will consider other  ways to fill the city 
﻿1   So we got a good setup, it gives us many opportunities to create interesting and at the same time different buildings  And with the help of the current setup, you can quickly create a whole library of buildings that can then be used for scattering or  placing on the stage. But how else can you make this setup even more interesting and convenient for users?  Well, there are a lot of things, but the first thing I want to tell you is how to turn what we have into a procedural city block  Before we get to this, let's quickly look at the current setup  On the second week, the homework was to continue working on your asset,  take out and arrange the control elements at the top level. And this is what my setup looks like now  I have slightly tidied up the interface,  tidied up the parameters and made sure that everything works. For example, if I have  a grid grid,  I get the correct floors 1, 2, 3 and  the correct tabs are displayed depending on the number of floors and so on. Here I cleaned everything up  I also changed some names. Instead of build and cache, I made live and load just to make it clearer  And I also made sure that everything that is not relevant at the moment became inactive  We already had such a function in this setup when we switch to the curve,  some parameters are changed. But I went even further and when something is connected, these parameters also become inactive  To do this, you need to create an invisible parameter. This is just a standard parameter with the value invisible  Let me show it so you can see what it is and what it does  Here the strCmp function is used, that is, the function of comparing lines  Note that in this comparison function I have written open input pass. Let me open the reference  And I will find this function string compare  And look, it compares two lines  In my case, here it is the first line, before the fifth and it says open input pass  I have already shown this expression before, it returns the path of the node that is written in this expression, that is, it returns  We compare the first argument with the second, the second I have an empty line  If something is connected, this path will be shown and they will be compared. And if we look at the reference  Here it says that if they are the same, then the path is the same, and if they are the same, then the path is the same  Here it says that if they are the same, then we get 0  If they are different, then we get 1  And how does it work if nothing is connected, then there is nothing here either  And we get 0  If something is connected, then it turns out that these two lines are different  And they will be different because this line will have this path written  And the second is an empty line and we get 1  That is, we use it as a switch  And for this switch in base settings we indicate if this parameter  First input inactive  As I called it here, if it is equal to 1, then all this becomes inactive  This is a very good convenient feature, it is also worth adding. Let me open it again  And it disappears  So, let's continue to disassemble this asset  Look, I also added extruding as a switch  Because this should not happen all the time  It is not always needed  And the longest edge will also be found  I also have two identical ones here  And I also adjusted the size of the roof when there is extrusion  And I also noticed that I need to change something  I noticed that I need to change the floor mount, it still needs to be active  I will open the properties again  And it should not be here  It should be here in size  Yes, that's better  Yes, that's better  That is, the number of floors still needs to be active  If I reduce  The size of the roof will still be correct  And there are still a couple of questions that need to be solved, but we will deal with them a little later  And let me show you the materials  I added materials for the first, second and third floors and also wood and stone  It was done the same way as we did for the second week  We added Atrib Wrangle  Created Shop Material Path  And then referred to this material in the material node at the end, sending it here to this channel  Well, the last thing in this setup, I made a horizontal turtle on the roof  Let me go inside  Instead of copying as before, we take these edges  These  Add Polypass, Resample  So that we have additional points  Convert to the line so that we have 7 primitives  Divide  Then create such a geometry  Slightly reduce the size  Here we remove the lower  Sorry, the side faces  Group the lower  Remove them and add Extrude  This is to have horizontal turtles everywhere and nothing sticks out on the edges  Here, however, we still have this problem, but we will fix it a little later this week  Well, that's it. As a result, I got such a generator  I will turn off the extrusion before we continue  Well, let's move on to creating a city block  So, to create a block, we first need to define its area  And then break it into the forms we need  Before that, we have already used the LapsLotSubDivide node  Let me add it  LapsLotSubDivision  Where is my grid? Here it is  We connect it to the LapsLotSubDivide node  And I'll make it bigger  Let's say 40 by 40  And now here we change some settings  I want us to have such a more or less uniform grid  And I want to have large blocks  Before we randomize them again, we first make it uniform  Like this, for example  I want them to be large enough  Now we have 9 primitives and we can scale them a little  I'll add ForEachConnectedPiece  Add Transform  Concentrate Pivot  And let's add the last one  Concentrate Pivot  And we probably need to divide them first  And we turn it off  Now there will be a small gap between them  Now each block will be a separate building  If I connect now, everything will work out as it should  Let's see the result  We have several such buildings  Something like a block  But they all look very similar  We'll figure it out later  So far they are located very close to each other  And their roofs intersect  We switch to a low-polygonal roof just to make it faster  So far the work is going well  But we need the buildings to be different  I think you can guess what we will do next  We can take this whole setup and put it in the cycle  We connect here  And we already have the class attribute  And we need to create new ones  This is the first one  And we need to create a new one  This is the first node  And this is the last one  I turn on Single Pass and we separate one building  And we have the same result  You probably noticed that this is not an asset that creates one building  If you want it to create one building  You need to save it as a new asset with a new definition  I'm happy with what we have  So I'll just keep working  If you want to create a separate asset  You can do it now  And first I want to control the height of the building  And here we already have different heights  We just need to sort it out somehow  For this we need our familiar module function again  I add Wrangle  I call it ID  I, dog, ID  You can call it whatever you want  And ID equals class attribute  Which we already have  We have three floors, so we write module 3  Don't worry about the type changes yet  It will still work  If I open the table, we will see  That we have an ID attribute  We need to change it to a primitive one  And it has values 0, 1, 2 changing in turn  And now instead of this switch  We add Switch If  Here we have the first floor  We get it from here  And from here we get the first and the second  I turn it on  And write  If ID equals 1  Then we switch to the second input  And I will do the same  Now we connect this node to the second input  If ID equals 2  Then we switch to this second input  I'll move this one to the side  I don't need it yet, but I'll leave it  Let it be  And now we go to the end  Until you contact me, I will leave it  And I will go to the end  Don't pay attention to the roof yet  Just skip it  Let me check again that we have set it up correctly  Ah, here are primitives  The same here  And look, we have a building of different heights  It looks more like a block  And we need to add a roof  We need to have the right displacement  So, on the first floor we need a roof  The first floor  The second floor needs its roof  And the third floor needs its roof  And the fourth floor needs its roof  Of course, at the end we need to make some order  The roof is not in the right place  I connected it wrong  And here everything is fine  And here, look, because we have merged twice  We don't need the third floor roof  At least not from this side  So, good  And we need one more merge  For these two  Like this  That's better  A little mess, but then we'll clean it all  And that's it, we have the roof  And we have a block  So, so far we have only varied the height of the building  But in fact we can change everything  For this you can use the methods  that we have studied in the previous lessons  For example, you can use the attribute iteration  And we can create a node with meta import  And you can rename it  in a shorter way  Let me remind you, when I rename a node  it doesn't affect its work  It's just a name  It's just easier for you to refer to it  when it has such a short name  So, instead of this long text  we'll have to write just an IT  when we write the expression  So, now we have the attribute iteration  And let's start  with the height of the roof  Let's find  where we defined the height  I think here  I'll remove this function  And I'll write a new expression  with the attribute iteration  and with the random function  I'll start with the attribute details  Just in case, if you haven't  remembered, I'll explain the logic  while I'm printing  So, we're looking for the attribute  details iteration  We're looking for it in the IT node  Then the name of the attribute  iteration  The main thing is to write it correctly  Yes, good, I missed it  So, this expression  will return the value of the attribute  iteration  We have a range from 0 to 8  It's randomized  In all buildings  it can be different  The random function will take  what we get from this function  and create a value  in the range from 0 to 1  And we take this random value  in the range from 0 to 1  And create a new range  I want it from 0.4 to 0.7  And now look  the height of the roof is already  within the expected range  If we come back here  we will have a variation of height  The wider the output range  the stronger the roof will be  And of course, you can also  change the height  And of course, you can  set up some switch  and on some houses  remove the roof  We can use  the attribute details  and perform randomization  make some roof with  or without it  somewhere the overlapping roof  somewhere they can be removed  and you can also change the material  I think it was a good example  I'll copy this expression  and go to the ground floor  Let's change the distance  between the windows  Now we have a distance of 2.2  I'll delete it  and paste what I copied  I don't think I copied  I'll take it again  I'll take it again  I'll change the range to 1.5  and 5  And let's see what happens  Now the windows are far  from each other, and somewhere close  Let's also change the width  and size  1.2 is the average  We'll make  from 0.6  to 1.5  So, some will be narrow  and some will be wide  So, the same logic  can be applied  anywhere in this building  for any elements  So, you can vary  some other things  like the number of balconies and so on  I think you got the idea  I won't continue  and add something else  Before we move on to the next lesson  I want to note one thing  We can also change this grid  For example, we can change  the angle of the grid  instead of a straight one  The division will still work  It will be more interesting  and different  As a result,  we'll have a building of this shape  not perfectly square  So, we got a block  We would need a lot of time  to create a whole city  Let's see another way  to create a big city  in the next video 
﻿1   This one with a curve and streets  And then some buildings to place manually  Again, it would be beautiful and effective and suitable for work in the foreground, since you control them as much as possible  I most likely use this method for foreground in this scene  Since I want the camera to fly over the city and the layout of the building should look more natural, I use OSM data  OpenStreetMap is a great database of cities  It contains the building tracks, street planning, roads, residential areas and other things  To use this data, you need to open this website openStreetMap.org  And then you find the city or layout that you like  Of course, you could find the area with the Cathedral of St. Sophia, but I decided to look for something more dense  Since I was in Croatia, I liked the city layout of Split. Let's find it  And here it immediately leads me to the city  And now I can choose any area that I like  Let's choose this one for example  Here I see the roads and I see that the buildings are located very close to each other, I like it  And then you just export  By the way, on the export tab, you can manually select another area  That is, I can change this box  You can select more precisely  Click on export  And that's it, the file was downloaded  Now we return to Houdini  So, we are back in Houdini, I think you will not be surprised to learn that there is an OSM import node  I think by this point you already understood that if you need to do something, create something in your scene in Houdini, there is a special node that can do it for you  Of course, there is an OSM import node  I will find the map that I downloaded, here it is  And let's check  Yes, and here it is  Well, you can immediately notice several things  First of all, we have very interesting shapes here, this is good and bad  There are also a lot of roads that you can work with  Well, to be honest, it is not immediately clear how to process them, we will return to this a little later  Let's start with cleanup  Along with the OSM import node, there is also an OSM filter node  I need two such nodes, one for buildings, the other for roads  And here we have a very interesting shape  Here you can see the road, here you can see the road  And here you can see the road  And here you can see the road  And here you can see the road  And here you can see the road  So, here I have a building  And here will be the roads  We will return to the road later  So, and now I want to move this OSM filter to the beginning of the coordinate  There is no specific reason for this, it will just be easier to work this way  That is, we again move the pivot  And here we will add the  And so we moved everything to the beginning of the coordinate  And then I want to add a delete node  And with the help of the box, delete what I don't need  I only need the area in the center, I don't need everything  You can take a little more  All right  Now let's look at these buildings  As you can see, we have such interesting shapes here  But there are shapes that can cause problems  For example, here they cut a little  Many are curved, there are zigzag shapes  And they can be processed in different ways, there are several ways  To begin with, you can take Lapse Delete Small Parts  So we can delete too small  I will increase the value and some of them will disappear, the smallest  Then the same, but this time we delete the larger ones  This is because later I want to replace them with churches, meadows, trees, etc.  All right  All right, we deleted some shapes, now let's clean them up a little  I will add a cycle  For Rich Connected Pieces  And we should have an Attribute Class  Although before we go further, let's delete some attributes  There are many useful attributes that we will need  But we don't need most of them, we can delete them  The same with groups  That's better  As I said, we already have an Attribute Class that was created with Delete Small Parts  So we don't need Connectivity anymore  And here I will add a Facet node inside  And here we turn on Remove Inline Points  I will show you the points so you can see what's going on  Here is a class that we will use to delete small parts  And we will also add a node to the node that we will use to delete small parts  And we will also add a node to the node that we will use to delete small parts  Some random points will be deleted, look here in this area  It checks the angle between the edges and removes some points  Although we may get strange shapes, we will deal with them later  So far we have cleaned up these shapes well  Now I just need to add a set of lines and triangles  So far I think it's not bad  Next I will add a node to the group expression  And I want to find triangles  This expression is called Triangles  I will call the group Blast  This is because after the Facet node we can have triangles  I think I don't have them here, but just in case it's better to do it  So we will have a more reliable set  And then the Blast node  So if after the Facet we have triangles  They will automatically be deleted  Only after the Facet we need to add a Fuse and merge the points  Excellent  I will reduce it a little  And that's it, I'll leave it like this  And if we have some strange shapes left, we can just delete them with the Blast node  Let's check the result  Ok  Next, everything is simple  We connect to this setup  And check the result  First I save the scene  And then I save the scene  And now we need to process 272 primitives  And before we can continue using this setup  We need to check that we saved everything correctly  Because if we can't count at least one of the buildings  Then the whole process will end in failure  And we will need to add the ProPolymbic node  And at the end I'll add the ProPolymbic  And I'll add the ProPolymbic node  I will enable the single pass  And I will add the frame number minus one  And look  We will process one building at a time  If there are problems we can fix them  Now we calculate them one by one  Here we select the render frame range and for the test let's try the first 10.  I save to disk.  Now they will all be completed.  And now to load them all back right away, we need the file merge node.  Here we need not a list of files, but a range of files.  I'll take this expression and insert it here.  This variable index variable is $f.  We just type f at the bottom and check that we should have buildings.  The range from 1 to 2, but we have 10 buildings, so we increase to 10.  And here we have buildings.  Let's see why we have nothing at the corners.  I'll go back to the roof.  So, for some reason there were no points selected here, that's why it didn't work.  But it was easy to fix.  And launch intact.  But the point something, because we are  And I'll run it again  Okay, now you need to create all the buildings. Let's try it.  And in the end we have 272 buildings.  And now we need to create a new building.  Okay, it's done. And now we have a part of the city.  And now it's all packed with Alembics. I'll explain what it means later.  And I'll tell you what a delayed loading and so on means.  And how to work with these assets in this state.  And in the next video we will deal with roads. 
﻿1   It will be more difficult with roads.  There are several ways to create them, both simple and more  complex.  But the most important thing is to decide where to start  these roads.  We could create several points and connect them with lines.  Or we could conduct them ourselves with curves.  Or, again, using the method with blocks.  That is, to make a road and then create blocks.  Or, in my case, we can use data from OpenStreetMap.  But let's start with the fact that in the last video I made a small  mistake.  You didn't have to move the building to zero.  Because roads take up much more space than the contours of the buildings.  Therefore, I cannot centricate the pivot and return them to zero.  Because then the buildings and roads will not coincide.  So I removed the expression $CEX in the Transform node.  And just moved it.  Okay, and now let's filter the roads with the OSM filter node.  Here we don't need buildings, we turn off the buildings, turn on the roads,  and we don't need everything else either.  I'll leave only Residential and Pedestrian.  And Other, other types of roads.  As with the buildings, here we will also remove all attributes and groups.  And we will take the same node with the box.  So that we have the same value for the road.  So that we have only roads left in this area.  But they are of course much longer.  Let's make the box larger too.  So that the roads are outside our limits.  Okay, I think it will work.  And now you need to check the lines themselves.  Make sure they look normal.  I think it would be possible to remove such small ones.  To do this, again, you can take the Lapse node, delete small parts.  Or you can just select and delete the Blast node.  And now we will remove the road.  And now we will remove the road.  And now, to make them a little bit better,  I will take the intersection stitch node.  So, we will combine them in the places where they intersect.  That is, here in these points.  And here, in this area,  well, and at the end I will add a poly pass  then facet  so we remove the extra points, turn on remove inline points  like this, for example,  then again resample  switch to subdiva  so great, we processed these lines, completed the cleanup, then there are several options for creating  roads themselves, we can start with the nodes that we have already seen, this is poly expand 2d  select offset surfaces and increase the value and as you can see we immediately get something similar to the road  let's clean them a little, look at the points here, for example, they are very close to each other,  I think they can be combined  distance by one and now triangles have appeared here  add labs quadrangulate  here we choose the longest edge method, the longest edge and all the quads will mostly remain  and after that I will add another fuse because somewhere we have points left over each other  somewhere else there are triangles, but I think it's okay, you can leave it  now to smooth the silhouette, let's add a node  labs edge smooth  and of course it's too much  you need to remove the edges at the end of the road  then create several groups  in one of them we include unshared edges so that we only have a border  in another node we include min and max edge angle  so we set a certain angle and thus group only the ends and now I will subtract one group from the other  and then smooth  and here we take only the inner edges  so we get such a smooth interpolation here  and in the end we got the roads, it was one of the ways to create them  it was a very simple way, but we have no overlays and now it will be very difficult to create them  we could of course try to create UVs, straighten them and so on,  but let's first try another way to create roads, we will take the labs raw generator node  you probably wonder why I took this node as the second way, although it is immediately said that it  creates roads, but in general it is always useful to try some simpler ways until you have problems  and then we will need to configure the parameters, let's first see what happened, one of the problems is  these are such angular elements,  and also each of them, each element is considered as a module that can be rearranged and  moved, and because of this such problematic areas arise, let's try to fix it,  first I will unlock the asset itself, we will go inside and add another setup, first reduce the resolution  first you need to find where this node starts to spoil our curve  here in this section we just have a modular system  and it copies the grid to all these points on the curve and let's follow it to this place  even a little higher  here where the poly bevel  I will turn it off  now we just have ribs here, now we go back here  and skip the full rich cycle, add a couple of zeros  I will move it to the very bottom  and I want to do a couple of things, first I will add a resample  and look it starts to spoil, this means that this is not an continuous curve,  you need to fix it with the poly pass node like this  and now to add thickness I will add a sweep  and I did this not just like that, the main reason is that here we have access to the uv attribute  I will select the ribbon, reduce the number of posts to 2 and increase the width  and now here we turn on the uv compute and now to fix the problems with the normals  we need to select the y-axis in the target up vector here  and let's export this instead of those modular elements  if we go to the upper level, our scale will change a little, they no longer match  to fix this, it would be possible to change the width of the module by 2, but this parameter is  not yet connected with anything, we need to copy it and connect it with the sweep node here  and so they will have the same width  now we need a width scalar, this is the width of the cross-section and multiply  this so that I can control them at the same time, I change this parameter and everything changes super  well, in the end I want to change some parameters  I will change the length to 4 broad lengths  convexity 0.25  just these are already checked settings that worked for me and I will reduce the blur of sharp angles  when they will be this problem  so we got the road, but we still need to make sidewalks  one of the ways to create them is to take the border of this road and add a sweep node  but we have already lost this border because we have already changed the asset itself inside  so we need to recreate it, I will add fuse to unite the points  and before we go further, let's delete the color attribute  so it's better  then I will add a divide node so that we have ribs again  this is only one of the ways, of course there are others  so good now we have borders  then you can add resample  again we switch to subdiv and again add subdiv and add subdiv  and we will add subdiv to the subdiv  and we will add subdiv to the subdiv  again we switch to subdiv and again add sweep  and then we unite with the roads again  and we need to increase the thickness, but first I will correct the normals and add UV  I will also include a re-determination of the existing UVs  and a little extrude up  that's all, we have created a subdiv and now we need to add a subdiv  and we have got roads  this was one of the ways to create roads based on OSM data  you can also add lampposts, I have already created them in advance  you can take this curve after resampling  and connect copy to points  I will also add orientation attributes  here we have columns  and we will add some more  we have a problem with normals  in orient and long curve we need to switch up vector to osy  and merge again  you could do it this way, but in my scene I decided to do it differently  I will show you how I did it  instead of creating roads, borders and raising this sidewalk above the ground  I decided to use boolean node and cut the road from the ground  I will add a grid and increase the scale  to cover the entire area  then we add the extrude volume node to the thickness  you can also add the thickness for this road  just a little, 2.5 meters or even less  and then take boolean node  and cut the road from the ground  just need to raise the road higher  great  I will add null  and delete attributes  because of them, it's black  it's not normal  great, we also have roads  and this way will be a little better  because when we return the building to its place  we can see the road  now they will be raised above the ground  and then you can add borders and sidewalks  add different objects, trees, light poles and so on  and at this we finish this week  we still need to discuss a lot  we need to discuss how to add materials for this whole scene  how to add lighting  how to create the whole scene  because so far we have only made a small part  but we will return to this in the next week  this week I would like to discuss some other advantages of the installation  and the use of packed primitives 
Translated by the club Translated by everyone  Before we finish this week, I wanted to help you figure out some terms, if you are unfamiliar with Houdini and the assembly of scenes in Houdini.  Since we are moving on to heavy scenes and intensive rendering,  it is useful to study different ways with which you can make the scene easier and rendering faster.  And in this regard, three terms are often used. These are packed primitives,  instantiating and delayed loading.  I think the first question is why this solution with packed primitives, delayed loading and  instances? What is the problem?  The problem is that when it comes to huge cities and landscapes, you can imagine how much geometry  is needed to create a scene. And we want to make the scene easier and reduce the time needed to start rendering.  If you need to calculate a lot of geometric data, then you can really simplify the launch.  The objects of the scene are just a set of information. And in Houdini, of course, you can even look at this information,  if you open the geometry spreadsheet. Here all this information is stored.  Well, the more objects, the more information. And quite often this information is the same.  If you use the same object again and again, this information will be the same.  And if we do not reduce the objects inside the scene in any way, then we just waste memory.  And here just the things like packed primitives are useful.  Instead of importing the object, that is, all its points and all the information at once,  we instead load a link to this object from the disk.  And then we already show it in the viewport or during rendering.  That is, if we want to use this object in the scene more than once, then instead of  loading it several times, we load it once. And then we place it in different ways on the scene,  so that we have one object in a number of places. And all its copies were described in one set of information.  And in addition, when rendering, we not only save time when loading the geometry,  but we also render only what we see, which reduces the time needed to start rendering.  So, these are the packed primitives. How about delayed loading and instantiation?  Well, delayed loading does something similar. It loads the geometry only when you need it.  But if you use packed primitives, this leads to the same result. Here, look,  here we have unpacked Alembic and a delayed loading is used. If we have BGO or something  entering through the node File, then we can turn on Delay Load Geometry. But if you choose  packed primitives, it will be almost the same. When instantiating, several copies of one object are also loaded.  If we go to the CopyToPoints node, we have already seen it before. And again I will show the full geometry.  It loads the instances only during rendering. And when the CopyToPoints node is used,  like here, we do not instantiate the standard geometry, we just copy it from the source or from any  other place where this object is located. If we want to instantiate during rendering,  then we turn on Packed Instance. This packs the geometry and places it on the point.  How does it work in practice? Let's first look at the mantra.  Here we have a loaded object and it is unpacked.  Here too.  And the scene itself becomes very slow, it is even difficult to move.  And if I check the volume of the memory used, then here it is more than 1.5 gigabytes. If I start rendering,  then for a start it will take some time. And by the end we will have about 4 gigabytes of RAM.  Well, although the rendering of the scene still happens quite quickly, so far not so bad.  Now let's try to add more instances.  Now let's see. Let's say twice as much.  And the volume of memory will not change. You only need additional memory for new building points.  But since we have the same geometry, it takes the same amount of memory.  And you can also notice the delay in the viewport.  As it loads more and more, we see fewer and fewer points. This saves the effectiveness of the scene.  Also here in Alembic, it would be possible to switch to the bounding box of the display.  Again, the scene could have become easier. Let me switch. Instead of the building, we will have just boxes.  But as an option, instead of this packed Alembic Copy to Points, it would be possible to apply the instance.  And this, by the way, was a good example of why we use such a working process.  I forgot that we had a size of 40 by 40 here. And when I switched to unpacked geometry again and copied to the scene point, it became too heavy.  I ran out of memory and the program flew out.  Well, in general, now we see unpacked geometry that is copied to the point.  And this time I want to turn on the Packed Instance.  Again, you can switch to the bounding box if you want.  And if I run the render.  And so we will not see any special improvements.  This is because packed primitives with mantras actually work very effectively.  Despite the fact that we also instance, it is still quite effective.  So this is Mantra.  Now let's look at Arnold.  So now we are rendering with Arnold.  We have a very similar setup, although Arnold actually does not work very well with Alembic files.  At least not as well as Mantra.  So if I start rendering, it will start a little slower.  And it takes more time to create geometry.  So, well, it all started.  And we use about two and a half gigabytes of memory.  This is a little less than Mantra, but it loaded longer.  And now I switch to the packed Alembic.  The render is running much faster, but at the same time about the same amount of memory is used.  And if you turn on Packed Instance, Arnold will become very effective.  If I connect the unpacked geometry again and start rendering, it will start immediately.  And at the same time, 300 to 400 megabytes of memory is used.  I could, of course, load the packed Alembic and also pack it here in the copy node.  But in fact, there is no advantage in this.  We just have to pack the geometry twice.  And later, because of this, there may be problems with rendering.  So there is no need for this.  So let's summarize.  With large scenes, the geometry for rendering can load for a very long time.  And packing geometry is a great way to shorten the loading time, because this way you will only have a link to the geometry that is then stored in the scene.  And copies of this geometry are created from the same link.  And then this geometry is created during rendering.  Packaging and instance is an even more effective method.  And geometry is not only loaded from one source, but from all the points that are in the scene separately.  But also, unlike packing geometry, which is then loaded during rendering,  at least Arnold uses the same geometry for each building when instance.  Therefore, memory is essentially spent on one building, plus on information about the transformation of each next instance.  The same is true for Mantra.  Only it has packed primitives and instances are very effective.  A little more than Arnold.  But the instance in this case, in this scenario, is a more effective method.  Okay, let's finish this week. I think that's enough for now.  This week we looked at many tools for building scenes and creating cities.  As a homework, I suggest you create your own setup,  do a clean-up, check that everything is well organized, that you have set up the blocks, set up the curves,  that you used the OSM data  and tried to make the renders more effective.  In general, we will talk about the effectiveness of rendering in the final week, when we will have everything assembled together.  But I think that this week it will be good to conduct several tests. Try different layouts,  different setups and see what suits you best.  And we move on to the next week. 