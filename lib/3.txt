Translated by the club Translated by everyone  This week we will talk about the Houdini basset.  We will take the existing setup and add all the necessary functionality and controls,  and turn it from a simple set of connected notes into an instrument that can be used in any network or passed on to other artists.  So, what is HDA?  HDA is a digital Houdini asset, also known as OTL or Operator Type List.  This node exists in the network beyond our walls, and it can be loaded into various Houdini files.  As soon as we turn the node into an asset, we can change everything we want, whether the nodes are inside or the parameters are at the top level.  And since this asset exists online, if we edit it, all other artists who uploaded it to their scene will also update this asset.  This can be both good and bad.  Although this is an advantage that these changes affect everyone, but sometimes a disadvantage.  Perhaps they don't want their asset to be updated.  But on the other hand, your updates can make their scenes more effective.  We will discuss this in more detail as we work.  We will start this week by studying how to create an asset.  And we will complete by adding additional functions to our current setup of buildings, which we will update and review every week as we change our needs.  So, let's move on to HDA. 
 Translated by the club. Hello again!  If you have never created assets in Houdini before, then in this lesson you will learn how to do it.  So far, all the work that we have done so far is in one Gion node that we created at the beginning.  It has its own definition of what it is.  We want to create our own version of this node.  We can start adding our parameters at the top level that will affect all nodes inside.  But instead of editing the current Gion node and updating it for everyone, or only for us, we will create our own asset.  As I said, it will be a digital asset of Houdini.  Let's go back to the program.  So, I opened Houdini.  If I go to the top level, then here I will have a Gion node.  This is where we created everything.  And what do we do? We click with the right mouse button.  Go to Digital Asset. Create Digital Asset.  We will open such a window in which we can give the name to the asset and choose where we want to add the asset.  I don't want to include my name or branch, that is, the stage of development, so I will turn off these flags, but I will leave the version.  And let it be saved in a specific place, in the library, but I want to remove the prefix category.  If I worked in a larger team of developers, it could be useful, but I don't need it.  Okay. And I will call it...  Building Generator. You can call it whatever you want.  And if you want, you can create a new one and rename it later. But now it suits me quite well.  Before I go to the place where I want to save it, let me tell you a little more about the variables and the pseudonym.  If you go to the Edit menu, you will find the Alliances Variables.  In the variable tab, you will see all the variable assets and their values.  Here you can also create new ones for this project.  For example, if I needed to pack this scene and pass it to my colleagues, or save it on another hard drive,  I could create a Project variable here.  On the left side we write Project, and on this side we add the path of some custom folder.  Let's say like this. Now I have this path.  If I go to one of these nodes and add a new one, just to show you, let's say File node.  Here I can write $project and this is my variable.  If I click the middle button on the parameters, you will see that it points to this path.  This is what I usually do, just to simplify the organization of the project.  Sometimes hard drives are filled and you move something to another drive.  And when you have a saved path, when you move something to a new hard drive, you just change the variable.  And all other paths will automatically be updated.  Let's go back to our asset menu.  We disabled the author, disabled the branch.  Let's call it again. Building Generator.  Version 1.  And I have an OTL folder, you may not have it.  But when you save the asset, it will be saved in this folder.  If you have an error, just check that you have this folder created.  The OTL folder is quite suitable, because this way you can share this asset with colleagues or other artists who work in the same project.  They all use the same OTL folder.  If you have some kind of global folder, you can save it.  Now click Create.  Here I will click Destroy All Spare Parameters.  Okay.  And I have a new node.  If I click on it, it will show me the new node.  Okay.  And I have a new node.  If I click on the middle button, let's see what it's called.  It's Geo Object Building Generator.  And look, there's a small lock at the bottom.  When the object is unlocked, it means that it is now active in your scene and no longer read from the disk.  If I click on the right button and select Match Current Definition, it will be blocked.  And now it reads from the disk.  But since I want to edit it, I click on the right button and allow the content to be edited.  When working with assets, you need to remember one thing.  When they are unlocked and they are active in your scene, any changes that you make only happen in your scene.  As soon as you click on the right button and select Save No Type, you will rewrite the definition in your scene and update it to the disk.  If someone works with this HDA, as I said, they will also update the asset.  So be careful when saving something.  And save a backup copy.  So now we have HDA, we saved it, let's add parameters.  So, open its properties.  And instead of going over all the parameters one by one, it would be boring.  Let's start using them and see what we will need later.  Click the right button, open Type Properties.  All existing folders can be left.  I'll just add a new one.  I'll take the folder and drag it here.  Right column.  And I'll call it Controls.  And look, here we have a mark and a name.  The mark is what we see in the interface itself.  And the folder or what you add here is a link to this attribute.  This is what we usually write in Wranglers or add in expressions.  These are their internal names.  You can leave folder 1 for now or call it differently.  You can even call it exactly the same, it doesn't matter.  I want to raise it up.  Let me turn all these folders.  Drag the parameter up, click Apply and Accept.  And now we have such a Controls tab.  And here we can add our parameters that will refer to the channels.  I think it's obvious that we need to add a polo size here.  I'll show you a few ways to do it.  I'll start with the simplest.  I'll open Type Properties again.  And I'll go into the node.  I'll find a grid here and drag the polo size right into this Controls folder.  And click Apply.  Look, the interface has changed.  We have a new link to the channel here.  I'll click Accept.  And now at the top level I can change it like this and control the size.  The idea here is to add as many parameters as the user will need when he uses this node.  And what is the difference between the two?  We can do something to prevent the node from being introduced with negative values.  I'll open the properties again.  I'll find a new parameter and I can block the range.  Let's say I don't want the size to be less than 2 meters or more than 10 meters.  I can block both.  And I'll add a new parameter.  I'll add a new parameter.  And I'll add a new parameter.  I can block both.  I can block both.  And before we use it, let's check that we can't go beyond this range.  We can't make less than 2 and more than 10.  Well, I'm fine. Click Apply and Accept.  And now I can't make less than 2.  This parameter doesn't allow me to make less or more than 10.  It is very important to block the parameters in such a way that the user cannot spoil the asset.  So that he understands in what range he can work.  Another great example of such parameters at the top level is the menu.  If we go to our setup, then here we have a switch.  How can we bring it to the top level?  We could drag it, but without any context, it's useless.  Let's create an organized menu instead.  Again, I'll click the right button.  Open Type Properties.  And now we add the menu to the Controls folder.  Ordered Menu.  And I know that this is a switch.  This is a type. I'll call it Floor Type.  In the menu, I will also enter Floor Type, only without gaps.  And everything in the linear letters.  Now, to add something to this menu, you need to go to the menu tab.  And here we enter a token or value and a label that corresponds to this value.  In this case, 0 means a grid.  And 1 is a curve.  And now we click Apply Accept again.  And we have this Floor Type parameter.  I can copy it, go inside.  And here insert a relative link.  And now, here at the top, I can switch between the grid and the curve.  Only you had to place them correctly.  My grid should be equal to 0.  This is the first input, and the curve is equal to 1.  This is the second input. Let's try again.  Everything is fine.  Now we can easily switch between them.  And look at this moment. We chose the curve.  And now, if we change the size, it will not affect anything.  And if I pass this asset to the artist as it is, it can get a little confused.  It will be unclear what is happening.  Therefore, you can hide some parameters.  I will open the properties again.  And here I have the size and floor type.  And here I will add a type.  And here I have the size and the type of the floor.  We can use logic operators in the parameter itself.  And thus hide some elements.  We need the hideWhen and disableWhen parameters.  We go to the size.  And we write a figure.  Then the name of the channel we refer to.  This is Floor Type.  And it is equal to 1.  If the type of the floor is equal to 1, that is, the curve, then the size of the grid will be hidden here.  And this is great.  So your artist will not get confused when working with these parameters.  And of course, we need to provide the artist with a curve access so that he can change it.  This can be done in different ways.  We will consider these methods in the following lessons.  But what if we want to add additional parameters to the menu?  Since here we said it is equal to 1, it would be better if we said that it was not equal to 0.  If the grid is not equal to 0, then we hide it.  In this case, the situation will be the same, but this means that when we add something to this menu later, it will still be saved and not be spoiled.  That's all, I think that's enough for now.  We will continue in the next lessons. 
 Translated by the club. Translated by everyone.  So we continue to create a procedural asset.  So we returned to our asset and let's start with the roof.  First, I want to put this roof in the undernet.  Oh, good that's back and running rear R U hat we took over from the considerable  And now you need to check that the links are working everywhere.  Yes, I think everything is fine.  So, then I want to add a switch so that you can choose  different types of roofs.  Great.  However, we still have a problem with the addition of tiles that hang over the edge.  But we will return to this in the next lesson and slightly correct the setup.  So, then you need to add a new menu for this switch so that you can  switch between different types of roofs.  So, I will add a new menu for this switch.  And now I will add a new menu for this switch.  So, I will add a new menu for this switch.  And now I will add a new menu for this switch.  And now I will add a new menu for this switch.  And now I will add a new menu for this switch.  And now I will add a new menu for this switch.  If you click with CTRL and the middle button, the default value will return again.  So here you can change the default settings.  I want to make 0.  And again we press Apply.  Great. And Accept.  I also want to bring up the smoke engines.  We also need parameters for them.  First, you need to control if they are there or not.  And the number.  Look, here we have the Delete node.  If we change the first parameter here, it changes the number of smoke engines.  Therefore, we need to bring up only this parameter.  Because then we will have either none or all.  And here you can also perform operations and make this parameter more convenient for the user.  But again, we will consider this later.  We will act step by step.  Let's first bring the parameter up.  And together with this parameter I want to add another switch.  This is so that the user can decide whether he needs smoke engines or not.  If we change this value to 0 ...  No, sorry, to 5.  Then we will not have smoke engines.  And we still perform an operation that does not need to be performed if we do not want smoke engines at all.  Therefore, instead of performing all these nodes, let's just switch to Null.  And let's say we do so many smoke engines.  And with the switch we just say that we will not have any.  This is our first switch.  This is much more effective and correct.  So again, add another menu and bring it up.  And here we will have only two options.  So instead of the menu, you can create that corner of the switch.  Let me close these first.  And we will not have any.  And now let's create another one.  And this will be our first switch.  Now we will have just one switch.  And here we will have another one.  Let me close these first.  Actually, let me hide these folders for now, because they are in the way here.  We select a folder and make it invisible.  Just temporarily.  Then we will make them visible again.  I think it's better this way.  Now add a toggle.  Drag it here.  And I will call it chimney with smoke engines.  Great. You can copy this parameter.  And now in this switch node we insert a link.  Now I can switch to the other one.  And now we can switch.  So we will have either smoke engines or not at all.  Let's check again that everything is switching correctly.  As an option, you can press this arrow, they will change places.  Everything is fine.  And finally we need to control the number of smoke engines.  Here.  Instead of dragging both parameters, you can create a new integer.  Here it is. Integer.  I will add it.  I have not created much�  Anyway, by the way, I have written the donations in this form.  I have streaming everything.  Let's recycle only the t überbund.  I want to clear my popamur with skills.  Now this image is counting the content.  I'll press Apply Accept.  I'll copy it again.  And paste it here.  Now we say that we want smokehoses and change their number.  So far we have inverted here, but we'll fix it later.  We finished with the roof, now we go to the floors.  We finished with the roof, now we need to do the same with the floors.  We finished with the roof, now we need to do the same with the floors.  We finished with the roof, now we need to do the same with the floors.  We finished with the roof, now we need to do the same with the floors.  We finished with the roof, now we need to do the same with the floors.  We finished with the roof, now we need to do the same with the floors.  We finished with the roof, now we need to do the same with the floors.  We finished with the roof, now we need to do the same with the floors.  So, I called the ground floor.  And I'll show you again, everything looks exactly the same.  So I think that all this can already be removed.  And we will only have the first floor.  Only there is no ground, no roof.  Let me check what's wrong here.  Ah, you still need to connect here.  Yes, everything is fine.  So, we've assembled it all.  So much more convenient. Now I want to add floors and a roof.  We talked about transformation by Y with the copy and transform node.  And then we replaced it with Wrangle attribute.  And I would choose this way.  But instead of adding here, I'll remove this node from here.  And I'll add here.  I'll copy and paste this whole setup.  I'll call it FirstFloor.  Then we'll shift and merge it here.  And we shift.  Only, of course, you need to change the link, because we are already at another level.  Now we are looking not here, but we are replacing it with GroundFloor.  So, we get the information from this node.  And then we merge it all.  And so we have floors and they are independent.  Separately from each other.  If we want to add another floor, then we do the same.  I'll copy and paste.  And I'll call it ThirdFloor.  So, this is already the third, SecondFloor.  And here we need Wrangle.  And here we need Wrangle.  And again, merge.  Only here you will need to replace the height.  Raise the previous floor to the height.  Here we take only the channel.  Copy.  And put them together.  Instead of the first floor, we need the second.  So we have another floor.  And look how quickly we get the building.  And let's add a roof.  I think you understand that we act in a similar way.  But we also need the third floor.  We also add it.  And I think we need to add a small offset.  But we have already done most of the work.  Yes, they intersect a little.  In general, let me add a small value here.  And then you can create a separate parameter for this.  For now, let it be 0.1.  And so we already get the building.  Super.  We still need to bring out a lot of parameters for these floors.  We will start with the height.  Then there will be a distance between the windows, the size and the location of the windows.  And that's it, I'm finishing it now.  Look, now again there is a delay.  So let's wait a few minutes.  And almost there.  Sometime there is some delay.  Quite teaspoon interval left there.  And we move on to the fifth floor.  Here I'll show you how to make the mortar block and畫燭.  and also as we did before, we take the parameter in the left column, add it to the right,  call it window height or ground window height  I will set the range and I do not want the window to be lower than 0.25 height can be any  because we can change the height of the first floor, I will leave 8  press apply accept  in general, you don't need to press apply accept every time, this is already just a habit, it is enough to press accept  and at the top level I will copy this new parameter window height I will go back and insert a link here  but of course here the value 0.25 it will be lower but I can change the default value  0.25 seems to me very little I will change the default value to 1.5  fine now we have several parameters here we can already change them at the  top level in the asset interface change window height and here you also need to change the range  so much better  so then we think what else we can control what else we need, for example, how many windows are closed  and how many are open or, for example, at what angle they are open, I will return back inside and find the  copy stamp that controls the window  here we have such expressions with ranges I don't want to change this node and add an additional  channel but I can change the interface, that is, it will not change anything in the asset itself in the node itself, we  will only change the parameters here we open the interface edit window all this I will turn  you can add integer or float integer is also suitable since we will work here in degrees  I will call the window open  I think you even need a ground window open  if you can always return and change these descriptions and names the range will be from 0 to 90  and apply accept here we now have a new parameter at the bottom, let me also change the default value to 90  and now you can create a link to this channel in the stamp node  just drag it here and here it will be created an expression here I can see what I  refer to and add here in the idea nothing will change but it will be much more convenient for us  this can be removed and now look we change this parameter windows open and close  I think you need to do the same for negative 90  copy this expression and insert here we will have a minus channel and on the other hand there will be the same  result super and now we can bring it to the top level again open the properties type properties  and just drag it here  and now here at the top we can open and close the window  super then I will do the same for the rest of the floors  and then we will return and work on the interface of the asset itself and here you need to fix something  and so I added all the necessary parameters at the top level that I think I  may need and what we already had I also added for the second and third floors and added  a few more additional parameters I added more height of the doors so that you can raise them  I removed the balcony from the lower floor and the steps from the second and third  I also added the roof height so that it could also be controlled here and took out the window size  I also tied the position of the doors on the second and third floors from the position of the balcony, that is,  when I move the door, the balcony moves with it, but now we have a lot of  parameters here, they are all just one common bunch, but now when we added all these  parameters, we have a complete mess here now I want to arrange these parameters in some way  to group them so that it is more convenient to work with them again I will open the properties  and I will show you several ways how to arrange it I will add another folder  then I will transfer everything that belongs to the first floor this is the ground floor  call ground or ground floor  and take everything all the parameters that have the word ground in the name everything that  belongs to the first floor and I think everything and this one and all move to that folder and now  in this folder we have all the parameters for the first floor, then I will open the properties again  and we will do the same for the other floors, add another folder this is the second floor first floor  and another one for the third floor second floor  and so now we have these two folders let's transfer the corresponding parameters there  and add another one for the roof  and so we have the first floor 2 3 and so on and I already like what happens, but that's not all  we will not stop at this we need to throw all this into the root folder controls  fine  just what we need  now everything is well organized and at the same time we need to hide the parameters that we do not use  I will add a switch with the help of this switch we will say whether we have  several floors or only one and need several merge nodes  one merge for the second floor  and one for all the rest  this is the second input  and at the end we add the roof  so we have a problem here  so far I will do the same I will take this wrangle  and I will have several different versions  one without the second and third floors  one with all three and one only with the first and second  and again we add a switch  only now you need to tie it all together  I will try again  and check that everything is correctly connected in the right order  now when we switch between them everything works as it should  at the end we will solve this problem in a different way until I run far ahead  let's leave everything as it is and of course it needs to be taken to the top level  I will call the floor amount the number of floors  and now we can hide some parameters we have already talked about how to do it  you can again use the same logical operators that we used for folders  the first floor will always be here but the second we can hide  when we chose only one floor that is when it is equal to zero  now this one hides when this value is equal to zero  and the same with the second floor  let's organize it better here  and so when floor amount is equal to zero we see only the first floor  if we change to one then we see two floors  only at the same time you need to hide the third floor  the third we say  if this parameter is not equal to two then we hide this one  and the same can be done with the second floor  if the parameter is not equal to one then this one hides  so great so far everything is going well  let's see what else can be done here how you can use folders and other parameters  so far we have created folders in the form of tabs but you can just choose simple these are simple folders  or there is also collapsible, too, very convenient such scrolls  and there are also radio buttons  in general, they are very similar to the tab, only so you can see which of them you chose  you can choose any type you like I will leave the tabs  but we can separate these folders from each other  and here we need to fix something here we have a roof here  and here I have turned on the end tab group need to be turned off  if you want to add the distance between these folders you can add a separator or spacer  let's try a spacer  so in general it was necessary to scroll up first and add here at the top I will apply and see  what happened the distance appeared you can change to large make it bigger  or you can add a separator such a horizontal line  and below you can add another one and make it large  in general, I think now you understand how you can organize and organize an interface with  parameters so that it is more convenient for the user and let me do something else  I will add a label label heading I will add at the top  I will call base settings  and now we have such a beautiful headline so that we understand what these are the parameters  I think this is enough  I noticed one mistake here with the floor amount parameter it does not work quite as we expected  we want both the second and third floors to be active when the number is equal to 2  I think that the first floor 2 must be hidden if it is equal to 0  no sorry equal equal 0  yes so better  so logical so in the next lesson we will move on to materials caching and saving  but I don't want to use shading yet I just want to add a path to materials in the objects themselves  this can be done even before the materials appear we go to the next lesson 
 This video is prepared by the Translation Club.  In this video we will complete the creation of our generator asset.  We need the opportunity to save assets on the disk and load them back, so that we do not have to create an asset every time.  At the same time, we can do this even more reliably by creating the following menu, so that it is easier to save and load assets by controlling the versions.  The idea is that we will have several options for this building and we will be able to save them and load them back.  At the same time, we will not have to count all the nodes and not create each separate element again.  At the end, we will also need to check that we have materials and that they can be used without the need to save the geometry every time.  But before we do this, I want to fix the roof.  We have already seen that it is a little damaged.  I will go inside and check the Convert Line node that I highlighted.  If I turn on Connect Pass, it will fix the roof, but it will also add central tiles.  But I want to control them separately, so we will just skip this node.  And so everything will work normally.  We will fix this setup, although now they are located below.  This also needs to be fixed.  Yes, that's better.  And we will check other setups.  Here I also added the Fuse node to remove these overlapping elements.  Okay, that's fixed. Now let's do the caching.  And for this I usually use the Alembic type.  In my opinion, this is a very reliable format and it can store a lot of information, so it doesn't work very well with such files.  And we will need to add the Alembic node.  Rob Alembic Output.  Here you need to select a path to save.  I will add a new folder here.  I will call it Building Cache or Building Library.  Name it however you like.  I will just call it Building Test or something like that.  .abc.  And you can click Save to Disk.  And now to load it back, I need to take the file again.  And connect it to the Out node.  Now you need to connect these two parameters.  Again, add a link to the channel.  I will copy this parameter and paste it in this node.  There is also an option to load in the mode of the delayed loading.  We will talk about this a little later, what it means.  While I leave Unpack Alembic.  As a result, we will have an active asset.  And you will not need to re-prepare all these nodes to get the final result.  And of course I can take this Save to Disk button up in the asset interface.  Open the properties again.  And now I will add a new folder.  And of course I can take this Save to Disk button up in the asset interface.  Open the properties again.  In general, let me show you.  You need to click with the right button and here select Type Properties.  And this Save to Disk button just drag it into the Controls folder.  And in the end it will appear here.  And to complete this step, I want to add a switch.  This is so that you can switch between the active version and the cached one.  I will create a menu.  We'll create a menu.  Zero will be the active version.  0 is the active version, live. 1 is cache.  Do not pay attention to this warning, it just says that the search will be  carried out this way.  Only to match with the rest of the project settings, you need to replace the  dollar project variable that I created.  Now you just need to copy this parameter  and paste it here.  I have some kind of error.  You need to check that I set everything right.  I have the wrong path here, I need to fix it.  Now I will update.  That's better.  Now I will go to the top level and try to save on the disk.  In the active version, everything will change. If I select cache, then nothing changes when I change the parameters.  This is great, but I want to make it more convenient for users.  I will add another menu, ordered menu.  I even need two menus.  I will add here.  We will call one of them building.  And the other one is version.  I will have options A, B, C.  The token and the tag will be the same.  AA, BB and CC.  And then version.  001, 002 and 003.  Okay, I will press apply accept.  Now we can copy the parameters.  I will add a new parameter.  I will add a new parameter.  I will add a new parameter.  Now we can copy the parameters.  And insert the links inside.  I will take this expression and insert it here.  If I click the middle button on the parameter, the name will be building A.  If I change the parameter to the top level, we will have a B and C version.  I will copy the version and add it to this path.  I will copy the version and add it to this path.  And now I will click the middle button and we will have a full line.  Now you can turn on AA here, and so far nothing will appear, because we have not saved anything.  Now I will save it to the disk.  And the A version is loaded.  I will switch to B. Again, nothing will happen.  Here you need to change and save again.  Now this is version B.  And let's try version C.  I will switch to Live.  And save to the disk.  And now I can switch between versions A, B and C.  And of course, the version changes, everything changes.  And it will be better if we connect these two parameters.  I will transfer this one here.  And here we combine them.  That is, horizontally, they will be in one line, next to each other.  I will also raise this one up.  And I will add a spacer between them.  So, not a bad start, but you can add something else.  Next, I want to discuss the materials.  How can they be added here?  So, to assign the materials, we need to add a node, a material node.  So that later it can be connected to them.  And I will add a spacer between them.  And I will add a spacer between them.  And I will add a spacer between them.  I will create several networks of the Material Network.  I will call them Plaster Clean and Plaster Dirty.  I will call them Plaster Clean and Plaster Dirty.  This is a clean plaster and dirty.  Now we return to the generator.  And I will add a node to the material.  And I will add a node to the material.  By the way, I will switch to Live.  And now I will go inside.  And here I will add a material node.  At the very end.  This node creates an attribute ShopMaterialPass.  If I open the table, we will see this attribute here.  If I open the table, we will see this attribute here.  I will add a link to our network.  And look, each primitive has the same material.  And look, each primitive has the same material.  But of course we want different.  But of course we want different.  We need several different materials.  Wood, plaster and so on.  How can this be done?  We go, for example, to the ground floor.  And here I have combined all the objects that should be with plaster.  And here I have combined all the objects that should be with plaster.  This is the ceiling of the floor and the walls.  I combined them with the Merge node.  And after Merge, I will add Wrangle.  You could add AttribCreate, but Wrangle will be more convenient.  You could add AttribCreate, but Wrangle will be more convenient.  And it is more effective, only not this one.  This one.  Here we work with primitives.  And create a new attribute like String.  That is, S. S is a dog.  I will open the table again.  And look, a new attribute Mat with the name Plaster has appeared in primitives.  And look, a new attribute Mat with the name Plaster has appeared in primitives.  Now I will return to the material, to the material node.  Now I will return to the material, to the material node.  And now we say.  And now we say.  We write Polygroup.  The dog Mat equals Plaster.  And look.  It is not designed for all geometry,  and only for some elements.  And then, of course, you need to bring it up.  And then, of course, you need to bring it up.  Again, we open the Type Properties property.  I will add a new folder for materials.  So that it is separate from everything else.  Great.  And now I will change the material.  I will change the label to Plaster.  So, now we can choose which file we need.  Cached or not.  And then we change the material at the top level.  That's it, we're done with the materials.  And the last thing I would like to do before moving on.  This one will perform a small cleanup here.  Before saving, you need to delete the group.  And I will add the Delete group.  Delete all.  We also add the Delete attribute.  And delete all unnecessary attributes.  Delete Door.  Height.  Class and Door.  Here you can delete all.  To do this, just type in an asterisk.  Now I will click the middle button on the node.  The file will become much easier. There is no more data here.  So, we get a pretty reliable setup.  But then I want to do a cleanup.  Here we need to fix a lot of things.  Different holes, hanging tiles, and so on.  So then we will add a new functionality.  And also clean up what we already have. 
 Translated by the club.  We have already got a working procedural asset, now let's add more functionality.  Let's start with the roof.  So far, everything works with square floors, but we want this asset to work with the floor of any type, so we need to update the stage.  So, we want to make the roof work with the wrong shapes.  For this, we need to take the current stage of the roof and modify it a little.  So far, we have central bricks on one side, and we need to add a new one on the other.  We need to take the central brick and divide it, so that we have corner bricks and then the flat bricks, which we can control separately.  We need to make the roof work with the same shapes, so we need to make the roof work with the same shapes.  Here, look, we have a custom shape and we don't have a flat brick, when we change from a square floor to a custom shape.  Let's add this functionality.  I'll move the nodes to the side.  Here, at the end, the central brick is already in the corner, and we need to make the roof work with the same shapes.  Here, at the end, we have the central lines.  First, I'll add the fuse node in front of the groups.  This is to have this central line and everything here is united.  And here, in the first group, I have all the ribs, then the next group is only the internal ones, because here I inverted, I took not the border, but the internal ones.  I'll move them a little further.  I'll turn off the unshared edges and turn on the min and max edge angle.  I'll make about 45 and 90.  And now I will have these jagged edges.  On the other hand, we take the group again.  Only we replace the replace existing, and here I will only have these horizontal ones.  Now I will copy some nodes from here.  And I definitely need the convert line.  Only in the dissolve node we select create disjoint polygons.  I don't need the fuse here, but I'll leave it just in case so that we don't have single points.  And I'll add the clean node to remove all the primitives that can be applied.  I definitely need this node, only we have flat, even ribs here, so these rotations are not needed here.  Let's see, I changed places, let's see what we have.  Great, exactly what we expected.  Only the problem is with the current tiles.  Here on the right side we have 0, but I generally want these origins to be at 0.  You can take all and transform to 0.  I just want to control it separately, so I'll copy these nodes.  And the center will be at 0.  I'll move these too.  And I need another copy.  And now we use this.  Only you need to change the scale, let's see which axis, z.  And I'll put it so that there is a small gap between them.  I'll copy these nodes.  So, on the right I have an angular  And then we just merge everything.  Super.  Transform needed to be lowered a little.  Okay, I'm quite satisfied.  So, we continue to work with the roof, and you probably noticed that we have absolutely no variations.  We could add a cycle for rich after we do all this.  And then randomize the tiles as we did before.  But since we already have points on which we copy these objects, let's just randomize attributes.  So, we go to the points, they were here, in my opinion.  And here I will add a trip randomize.  At first, it randomizes the color, it turns out cool, we will use it later.  But now I want to randomize the vector up.  We change the value.  And we turn on the flag Use First Dimensions Parameters.  Now you can change these two and decide how they will be located.  Or instead we can add a blend shape, why not.  And we will mix the original options with the new ones.  And we will add a slider with which we can add additional variations.  And while we are not going further, in the node AttyPrandomize there is another very interesting option, two values.  So we can save most of the tiles the same and add some variations.  I will leave this option.  Next, I want to delete some tiles.  You can do this in SOPS, but let's try using VEX.  Add Wrangle.  And now we will consider how to use the operator If.  So we are going to delete the points.  And I will create a new attribute ID.  I need a unique ID for each point.  I already have one, that is, the number of points.  If we check the data table, then we will find here a new ID attribute that is equal to the number of points.  But I need to randomize it.  We could add a sort node and select the random method, as we did before.  But instead, let's try to randomize on VEX to find out something new.  Let's write the RAND function.  It is quite suitable, but it creates a value in the range from 0 to 1.  This is not quite suitable for us.  I will indicate the type F.  I just want it to be an integer.  I want not from 0 to 1, but from 0 to 1.  And the new range from 0 to the maximum number of points.  In this case, I have 828 points.  This information will not help me much, because the input data will always change.  But we have an attribute that can be used here.  It always returns the total number of points to us.  But since we start from 0, we subtract 1.  This is in brackets.  And in the end, we created an random ID for each point.  But still in the range from 0 to the maximum number of points.  Now we need to delete a certain number of points.  For this, we write if id.  And here we need to enter some number, but to make it more convenient, we create a channel for this.  We call it threshold.  If this id is below this threshold value, we delete the point.  For this, there is a special function removePoint.  We write removePoint.  And the first thing to indicate is the input.  We know that this is the first flow in Wrangler, that is, 0.  And the second is what point we want to delete.  If we reach this threshold.  We delete the point that is being processed in Wrangler at the moment, because it is overriding the point.  Of course, you can say that if the id is below a certain value, then delete a specific point.  And we could enter the number of points.  But we want to delete the current one.  Drink us.  And close.  And here we need another number.  And you still need to create a threshold parameter.  And without missing a point.  Now I switch to the viewport.  I will show the points and I will increase the threshold.  And look, we deleted some points.  I just want to edit the threshold.  I will open the interface editing window and change it.  So far I made 1000.  And look, everything works.  Now they are deleted somehow voluntarily.  To make this setup more reliable, let's change the num5 to 100.  And instead of integer id we will have a float.  And if we now check the table, we will get such a value in the form of a percent.  It remains only to change the threshold.  Instead of integer we also make a float from 0 to 100.  And now we can control this removal in percent.  And now we can see the result.  And let's check now.  And now we can remove the tiles.  Also change the orientation and slightly randomize.  And the next thing I want to fix is these hanging tiles.  Especially when they are offset.  And now we will fix the hanging tile.  This happens because of offset.  I want to turn it off.  But I can't use the bound node here, because it creates a box for me.  Instead, we take the incoming plane, that is, the ground plane.  But it should be a little thicker.  First, it needs to be transformed.  And it is transformed at a fairly high value.  So that we don't cut the roof anywhere, say 50.  And then we take extrude volume and add thickness.  And now we can see the result.  And now we can see the result.  And now we take extrude volume and add thickness.  Let's say minus 100.  As a result, we will have a huge volume that will never be less than the roof.  Next, we need a boolean node.  This node goes to the first input, the turtle goes to the second.  The second input, in the second input we have the surface, the surface.  And the intersect method.  And if I connect it like this, we'll see.  Yes, great.  But it turned out to be very close.  We cut off not very accurately.  I'll add a peak node and we'll fix it.  We'll increase this volume a little.  Let's see where we cut off.  Well, that's not bad, I think.  And look, we have a turtle with a thickness.  We could add another extrude or go back to this one.  Remove and add after.  Well, the same thing needs to be done with other types of roofs.  Great.  And we did it.  And now we just need to raise these.  I think we have different types of roofs, their location is a little different.  But I think it's okay, we can add this transform and connect it to the switch.  So that it also changes depending on the type of roof.  That's it, I think it's better this way.  So we placed them more accurately.  And then we need to make sure that these changes are with all types of roofs.  Then in the next video we will start improving the main building. 
 Translated by the club.  We improved the roof, now let's move on to the building itself.  There are several final additions that I would like to add to my setup,  judging by the references.  And I want to add some additional functionality.  The first thing we need is to allow the user or us to update the custom curve without unlocking the asset.  Since we started with the Geometry node, from which the asset was created,  the easiest way to improve the convenience of using the asset is to use the so-called dive targets.  We need to double-click on the asset to get access to the area where we allow these updates.  The second way is to add the Merge node, the Merge object inside the asset,  and create input data for it at the top level.  Let's start with the dive targets.  It will be easy.  First, we need to put the curve here in the new subnet.  Okay, and now at the top level, I'll open the asset properties, Type Properties.  And I'll add the Merge node.  And the Merge node will be the same as before.  And now I'll add the Merge node to the subnet.  And I'll add the Merge node to the subnet.  And I'll add the Merge node to the subnet.  Okay, and now at the top level, I'll open the asset properties, Type Properties.  I'll go to the Note tab.  And now I can write this subnet, this target node.  We can edit this node, and it will be a dive target.  I'll press Apply Accept.  And I need to save it, press Match current definition.  Look, here's a little icon.  It means we have a dive target.  If I double click, I'll get to this curve right away.  And this is cool, because now I can edit it and thus change the output data.  This was one of the ways.  The second way is to add input data to the top level.  I'll go to this level, open the asset properties again.  And I'll go to the Basic tab.  Here I can change the number of inputs, maximum inputs by 2.  Again, Apply Accept.  And now we'll remove this target node.  I'll just delete it.  As a result, of course, the dive target will no longer work, but it's okay.  In this way, we will not use it.  And I'll just add a geometric file node, for example.  And inside I'll add a file.  And inside I'll add this curve.  You can delete the subnet, it is no longer needed.  Only the curve.  And I'll add Object Merge.  In this case, select Into this object.  And here I will need to change VEX.  We write the expression in such reverse checkboxes.  The expression will be OpenputPass.  In brackets we write a line that denotes the node name.  And the second is the index.  To indicate the node, we write two points in these apostrophes.  Thus, we return the path to this input object.  The number of points is the number of levels.  And the second input, which is the first, its number is 0.  Now I will go to the upper level and connect.  We will receive data from the second input.  And if I perform the expression, see what the path looks like.  And now how to add more functionality here?  This can be done in two ways.  I will show the one that I like the most.  If we want to use this input curve, we need a falling list.  But instead we can make such a setup and say that if something is connected to the second input, then use it instead.  We can add an expression here, but in general we have a switchif node.  It does it for us.  We connect like this.  It already has two inputs.  But we can enter certain conditions and check the second input.  We can check the number of elements.  And we say that if the number of points is more than 0, that is, if something is transferred to the second input,  then the node will switch to this second input.  If I connect like this  and delete this,  look, it switches to the first input.  And I think it's much more convenient this way.  Only now I need to remove this menu that we added before.  As a result, at the top level we should have exactly the same functionality.  Yes, it works for me.  Then I want to introduce some variations here.  Let's start with wooden elements on the corners.  And probably change the materials on different floors.  So we start with corner racks.  We need to create similar setups.  Similar to those that we had before.  We take the existing corner racks and copy the box with the height equal to the height of the floor.  So, again, we need the Copy to Points node.  We take the initial data and we can hold ALT and thus change the connection.  Add an additional point.  Next, I'll add a box.  I'll copy it here and merge it.  And now we need to change something.  First, I'll reduce the size.  In general, I want to make it even smaller.  But we'll fix this in a couple of seconds.  And again, the center needs to be divided into two.  Relatively high, so that the base always stood on the ground.  And of course, you need to figure out the orientation.  I'll take this node and connect it here.  We turned a little wrong, so I'll choose Previous Edge.  Then there will be the correct orientation.  But we went too far.  We have a thickness at the walls, in theory.  We need to extrude a little.  Or, more precisely, we need to make the walls thicker.  And we need to make the walls thicker.  And we need to make the walls thicker.  And we need to add an inset.  Or, more precisely, we need to add an inset.  Here we need to move to the same distance as the wall thickness.  Therefore, we can connect with this parameter.  Copy the wall thickness and paste a relative link to the inset.  Only a minus is needed, so multiply by minus one.  Not minus two, but minus one.  So, again, this angle.  Let's ignore it for now.  Okay, and the height should be the same as the wall.  Therefore, I will copy this parameter.  And I'll put it here.  And in the end we got such racks at the corners.  But they are probably a little further than I wanted.  We don't need the side sides, here we have an extra inner edge.  I'll add the Divide node.  And delete Unshared Edges.  And turn on Remove Shared Edges.  And now look at the Extrude field.  We have this inner edge that can be removed.  Well, it worked.  But still too far.  You can slightly adjust this displacement.  You can clear out something or multiply by a number.  Not by minus one, but by zero nine, for example.  Or by some other appropriate value.  Okay, I'll leave it like this.  But let's check that it works.  I'll change some parameters.  Yes, it will go down well.  So, the corner racks are done.  What if we add now the distance between the floors,  adding something wooden between them?  This can be done in several ways.  You could take these edge edges, add thickness,  using sweep or something like that.  And shift in height.  Let's consider another way.  Let's take another Extrude field and use Group nodes.  So, we need to add a couple of additional nodes here.  I'll add another Extrude field.  And here I need the upper faces.  It's easiest to group them.  And let's do it the normal way.  Keep by Normals.  It should be directed up by Y.  And let's take the upper faces.  And let's take the lower faces.  And let's take the upper faces.  And let's take the upper faces.  It's easier to group them up by Y.  Group primitives, and here we can reduce them.  So we've only selected the upper faces.  And we can make this spread very small,  so it will always work.  We can call it a Top group.  And then in the Extrude field we only extrude the Top group.  these upper faces.  I think we need to add thickness here.  We need another side group.  Then add another polyextrude.  Here we select this group side  and add thickness.  We extruded a little inside, but it's okay.  Yes, good.  We have a small difficulty here, the height does not match with this one.  So it would be good not to influence it too much.  You can reduce this height to this distance. I copy the parameter.  And now in this node Wall Height we insert a relative link and write a minus here.  Yes, that's right.  Now everything is as it should be.  We need to add a switch so that we can switch between versions with this additional and without it.  We have everything set up and we need to check that all the groups are named correctly so that we can assign the materials later.  We have this group and this side group XSide.  Here it should also be called XSide.  Let's check, add a color node.  I'll choose any one so that you can check.  I'll select this side group and see now it's a different color.  Later we can use it.  So, then we add damage to the edges.  As a result, we will have three options. One without damage, one with wood, and then another one with small damage to the edges.  So, as for damage to the edges, we need to take the existing edges of the wall or corners,  throw points at these corners and then randomly copy some objects that we can then cut out of the wall with a boolean node.  Let's skip this part for now and then disconnect.  So, we need these corner edges.  And we already have a setup where we create the wall thickness.  Here in this node, here we have the correct size.  Here I again extrude up the same node so that it matches the other side.  Now we have height.  Then we separate only the edges.  We can again take the group node.  Group the edges.  Include by edges.  And the angle is 180.  And here, probably, 0.  So, we have a group of objects.  But the scatter node will not allow you to scatter on these edges.  Therefore, first we add dissolve and create curves.  So, great. Only the edges are left.  Then we add the scatter node.  And we add the group node.  And we add the group node.  So, great. Only the edges are left.  Then we add the scatter node.  Although, in general, it is better to add scatter align.  I'll take scatter.  And reduce relaxation.  Next, you need to create some objects.  I'll start with a box.  And I'll divide it.  And I'll divide it.  So I get more even polygons.  Than if I started with a sphere.  Then add mounting.  To add some noise.  Then copy the node.  Change the size.  And we add a group of objects.  And we add a group of objects.  And we add some noise.  And we add some noise.  And we add some noise.  And we need to set up the orientation.  You don't need to control it as accurately as possible, so it's enough to randomize the node with atrip.  Write the attribute Orient.  And so we will have a random orientation.  And do the same with scale.  And do the same with scale.  This is the PScale attribute.  And increase.  And we got a set of random objects with random orientation.  And then we need boolean node.  We read them from the wall.  And we got some damage on the corners.  Something strange is happening here.  And we need to increase the size.  Actually it's not that bad.  But just a little bit smaller.  I think it's not bad.  But we have some problems with normals.  So we need to create a new node or facet.  And create normals.  Yes, like this.  Super.  And so we have a new node.  So, next I want...  But we have some problems with normals.  We will fix them later.  Now we need to add extrusion on the other side.  Let's add it at the end.  Normals.  I will add normal node.  It's better this way.  So, we go to the first floor.  And here we will start adding extrusion.  To have the most reliable asset,  I decided to add these different extrusion.  I mean, protrusions.  Or hanging parts on the second floor.  But only on the long edge.  Then we won't have any problem  if we choose silver by accident.  Extrude it.  And intersect with the other part of the building.  We won't have such a problem.  Of course, such a problem can only occur  if we perform extrusion by procedure.  If we choose ribs manually,  everything would be fine.  Or if we had a dive target.  But our course is dedicated to procedure.  So we need to find some solution.  And so we have a new node.  And we will add it.  And so we have a new node.  And so we have a new node.  And so we have a new node.  So, I went to the second floor node.  And before we move on to all this,  I want to add the second polyextrude.  Let me move it all.  And before resample.  Here.  And so we can define the longest rib.  And for this we have a special node.  And so we have a special node.  This is ConvertLine node.  It calculates the length of RestLength  of any primitive that makes up this figure.  I will add ConvertLine.  And now we have  the RestLength attribute,  which is stored on primitives.  So we can automatically check  which rib is the longest.  It's great, but now we changed the geometry.  Our ribs became primitives.  And the inner primitive is gone.  But we want to save this information.  And return to the original geometry.  But since we only need information  about the longest rib,  we can save this information  in the Detail attribute.  From primitives to details.  And check the table.  It's not here.  Now it appeared on the details tab.  But we need to change the method to the maximum.  Now we have the exact maximum value here.  And I want to save the original.  Because later we need to compare it with something.  So now we have  the longest rib.  And let's take Wrangle.  And we will add any rib  corresponding to this value  to this new group.  To do this, we write  IfRestLength.  This is an attribute on primitives.  And we need to change it to primitives.  If it is equal to the value  that we saved in the Detail attribute,  this is the maximum value.  We are looking for the first stream of geometry,  the RestLength attribute.  And zero at the end.  This value is usually ignored.  And now we set the group.  SetPrimGroup.  This is a new expression.  Again, zero.  This is the input.  The new group will be called ExtrusionGroup.  We are working on primitives,  so PrimNum is the current primitive.  And we set this group.  I think I missed some argument.  Let's check.  ShowHandle,  PrintName, PrimNum,  and here is IntValue.  This is to put a primitive in the group.  Yes or no?  We want it to be placed in this group.  Great.  And if we now check primitives in the data table,  I will have a group.  And in it will be some ribs.  In this case, I have two of them,  the longest ribs, 0 and 5.  They are both in this group.  If I show the numbers of primitives in the viewport,  here they are 0 and 5,  they have the same length.  It suits me quite well,  but if it were a little longer,  there would be only one rib in the group.  In this case, you can leave 2.  So now we know the longest primitive,  it is called ExtrusionGroup.  Now we know the longest primitive,  it is in the group,  but we cannot use it  as it is in the PolyExtrude node.  Because we need a group of ribs,  and now it is a group of primitives.  So we add GroupRomode to the node  and move from primitives  to ribs.  And we take only elements  that are completely contained in the original group.  Now we have two ribs.  And we need to convert them back into primitives,  for this you can take the PolyPass node.  We turn on Make Isolated Loops Closed.  So we closed everything  and saved the group of ribs.  Next, you can take PolyExtrude  and select this group of ribs here.  So now we have this  additional extrusion.  Next, you need to do the same  as we did before.  Remove the excess ribs of the Dissolve node.  Oh no, sorry, not Dissolve, but Divide.  And check the points.  We make sure that nothing remains.  If there are such points,  we take the Facet node.  And turn on Remove Inline Points.  Great!  And of course, you need to check  that they are connected.  Oh, we should have connected it here.  Yes, that's right.  Great!  Now if I go to the level higher  and check the final result,  we will have this group of ribs.  And we will have this group of ribs.  And we will have such groups.  Maybe you need it, maybe you don't,  but this is how we do it.  It's a little more interesting and more complicated.  I had such examples on the references.  Well, that's it.  I think while we stop with this asset,  we have already improved it enough.  Let me tell you about your homework  and what we will do  next week.  Your task this week is  to work with the lessons,  do everything you lack,  and you will also need to  make the network order.  If we look at all the additions  that we have introduced into this setup,  it would be nice to add  different switches.  For example, here for  damage to the edges,  for additional wooden details,  for these protrusions,  floors, and so on.  And also your task  to take all these things,  all these parameters  to the top level,  so that you can manage them from there.  Or if you have some additional  control elements for your  specific setup, you can also  take them up.  Next week I will show you how I  do this problem. 