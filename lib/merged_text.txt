Welcome to the second week.  On the first week, we have considered all the main working processes that we will use throughout the course.  And on the second week we will already start practicing.  This week we will start creating our procedural setup,  which will use only one input geometry.  This week we have 7 lessons, each of which is dedicated to an important part of the process.  We will start this week with creating floors, walls and boolean notes.  Then we will move on to creating fully procedural windows, doors and stairs.  Again, we will use one grid for this and we will vary the options for the location of doors and windows.  On the second half of the week we will start creating both low and high floors.  Then we will add balconies and smoke chambers.  Before we start, I would like to tell you about some things that are important to take into account when creating this setup.  The first thing we need is one input geometry.  This can be a box, a grid or a curve.  And it will be easier for other artists to work with your asset, with your tool.  And what you need to think about first of all, about the end user,  it can be you, if you plan to use the asset yourself.  But it is best to treat the setup as a whole, as a whole, as a whole.  And if you want to use the whole set, then you can use the whole set.  And it is best to treat the setup as a whole, as a whole, as a whole.  And it is best to treat the setup as a whole, as a whole.  And it is best to treat the setup as a whole, as a whole.  And it is best to treat the setup as a whole, as a whole.  And it is best to treat the setup as a whole, as a whole.  And it is best to treat the setup as a whole, as a whole.  And it is best to treat the setup as a whole, as a whole.  And this is everything that is needed to night set up your asset.  And here we can think about changing elements by adding your asset.  For example, we can increase the size of our open 
Translated by the club Translated by everyone  So, on the first lesson of the second week, we will start creating a setup for a procedural building.  We will start with the floors, walls and we will use boolean nodes to cut out windows.  Before moving on to the gudene, let's first look at the references.  Of course, your references may differ from mine, but I just want to explain why I chose this building.  I collected these references because these buildings look pretty harmonious in combination with each other.  That is, they are quite suitable for a procedural setup, where we want to use one tool to create several different types of the same building.  We have enough variations here, I think we can get a pretty good result.  In general, we will make such townhouses, square with pokatys and roofs.  And I will try to do everything possible to make the result look like these references.  It very often happens that you forget about references when you start mastering a new skill or a new technique.  But thanks to references, your result will be much better.  So, let's move on to gudene and start creating a procedural setup.  If you are watching my lessons for the first time, then you probably do not know that I usually start everything from scratch.  I will not use any plugins or existing nodes, presets, only gudene.  A little later we will use the labs tools, but for now I just need an empty Gio node.  To start, we will create a floor. I need a grid.  I will make it 5 by 5.  This is, of course, a random number, but the building that you saw on the references is about 5 by 5 meters.  And I will remind you that in gudene we work in meters, that is, one unit is a meter.  And so far I do not need rows of pillars, so I will just leave 2.  And let's call it floor. We need a thickness.  I will add a polyextrude.  Let it be 0.2.  No, 0.2 is probably a lot. 0.1.  And it has no base, so you need to add it by turning on the output back.  So, this will be the floor. I will immediately add null to indicate that this is our floor.  Next we need walls.  Again, I will add null.  I will call it walls.  This is just so that when someone else opens your setup, he can roughly understand what is happening.  Or if you return to this asset a year later, you will understand what is here and why.  I will add another polyextrude for walls.  I think 3 meters will be enough.  And here you don't need the front side, only the side ones.  And I want to increase the wall thickness. This will be the last polyextrude.  You could even rename these nodes.  Here we changed the height of the walls.  Again, you will better understand what these nodes are for.  Let's try 0.2, 0.1, 0.2.  No, wrong.  And here I need the back part.  Output back.  And we need to close all these surfaces, because we will use boolean nodes later.  And the last thing we need is the ceiling.  I will add null and call ceiling ceiling.  Let's start with the floor.  We need to raise it up.  Here we need to transform node.  But we can take Wrangle instead. Why not?  The sooner we start adding Wrangle, the better.  And I want the ceiling to be at the same height as the walls.  So I think after the first week you will understand what we need to do.  We go to the height of the wall, copy this parameter.  And in Wrangle I will insert a relative link.  However, a couple of things will be done that I do not need.  This I do not need.  And this is not a string.  I will remove s, because chs is channel string.  But we do not need the string string.  And this is all we need now.  Now I will say what I will do with this link.  I want to take a position by y.  We take a position and add this height.  That is, the current value of p.y is equal to  p.y plus is a new distance.  And it worked.  It rose above the ground.  Although this is not very effective, let's fix it.  So what did I do?  We basically do the same thing.  Plus is equal to when a existing position is taken and all this is added.  Instead of repeating p.y again.  And if we combine all this, we see that something went wrong.  Now we will fix it.  We will combine everything.  I think you already understand what is wrong.  It is too high.  Again, it is possible that you already imagine how to fix it.  It's good if you think for yourself and try to solve this problem.  Do not wait until I tell you.  I will give you time to think.  This displacement is the height of the floor.  That is, the thickness.  We raised it too high.  We need to subtract this thickness of the floor.  And instead of copying, inserting and rewriting everything,  I'll just write down the minus.  And now I will find this channel.  That's all.  And all this is connected.  If I change the size of the grid, everything will be adjusted.  If I change the height of the wall, everything will also be adjusted.  Great.  Next we make windows.  First we need a box.  And again, null.  Just to indicate that windows are starting here.  And again, null.  Just to indicate that windows are starting here.  Actually, no, it was not necessary to connect.  Okay, we'll come back and fix it a little later.  Let's first deal with the windows.  So, first we need points on which the windows will be copied.  To get these points, I will add a Resample node.  And look, I already have points turned on here, so we see how many of them.  But we need to do a couple more actions, or at least one.  First, we do resampling on the edges.  This is so that the points are at an equal distance from each other.  If I lengthen the grid, we will keep this distance.  And this is important because we do not want the windows to change due to the length of the original geometry.  Okay, now we add CopyToPoints.  Great, everything turned out as we expected.  Only a little less.  So, only one of the problems is that we have corner points left.  We also copy on them, but we don't need it.  That is, we do not want the windows to be located at the corners.  And again, if you think well, then you may already imagine how this can be bypassed or corrected.  We cannot just select them and delete them.  Because when the input geometry changes, if we use Blast, the number of points will change and everything will be ruined.  Instead, we need to somehow remember where these corner points are located before and after resampling.  This is where procedural working processes begin to play an even greater role.  But at least now you will see the full power of these processes.  So, as in the first week, to find and save these corner points, I will take a sphere, make a polygonal mesh and copy it to the original grid.  I will reduce it a little.  So that I have only so many points left.  And then after resampling, I want to group the corner points.  We connect the node, switch to the point, name it corner.  And I will turn on Keep and Bounding Regions.  And we choose Bounding Object.  Great, now we only have these points.  The rest do not enter the group.  Next, you can take Blast.  We select the corner group.  And so we deleted these corner points.  So, now we have points with windows, but we do not have normals.  If I change the window shape, I will make it more accurate.  Height is 1.6 by y.  Depth is 0.6 by z.  As you can see, they are oriented incorrectly.  Before deleting something, I will add Orient Along Curve to correct normals.  And y should be directed up.  And here let's make the correct orientation.  With the help of additional turns.  Great, now we have a corner point.  They are a little low, so I will add a Transform node and raise them.  Again, all this can be corrected later.  And then we take Boolean node.  I want this to affect only the walls.  And so we have a corner point.  A-B  So, Solid, Solid, Subtract, A-B  Great.  Everything worked out.  We have windows, we have walls.  Still a little low.  So, we only have this geometry left.  These connections, these.  And I think it will be okay to render, but just in case.  I think you need to divide it a little by length.  This is just to reduce the probability of artifacts appearing during rendering.  Therefore, instead of starting with this grid and connecting it to the walls,  I will start with this Resample.  I will connect it to the walls.  As a result, we will have a division where the windows are.  I think it will be better.  So, okay, here we took the grid as a basis.  Well, what if you want something not so standard?  Maybe some kind of custom shape?  Let's try to take a curve instead of a grid.  Only before I do this, I will add a null.  And I will transfer these connections here.  Let's call it Start or Begin.  To indicate that this is the beginning.  Everything starts here.  This means that I can now quickly switch to this curve.  I will not have to reconnect three or four different streams of nodes.  So, I will select the node with a curve.  I will press Enter in the viewport.  I have already turned on the grid binding.  If you don't have it, I would turn it on and change it to a polygonal one.  You can start with a curve without a curve,  but it creates overlapping points in those places that can cause difficulties later.  Therefore, I will leave the polygonal one.  And let me check how big the grid was.  So that we have about the same size.  And create a new shape.  I'm drawing something.  Great.  But maybe you did the opposite.  Did you notice? I was going clockwise.  If you were doing a curve against the clock,  then maybe you would get something like this.  This is just a polygon turned the other way.  If you press Reverse,  if you select this button,  select Edit Mode and press Reverse,  then the orientation will be corrected.  And it looks like I have a problem with normals.  Let me look at it from another angle.  Yes, it looks flat.  So far, everything is fine.  I will leave the polygonal one.  And let's look at the final result.  We switch to a curve and we get a new shape.  And if we change the original,  take this edge and move it,  we will get a great procedural building.  Well, at least its beginning.  Well, at the end of the drawing,  I will leave the polygonal one.  And I will leave the polygonal one.  Well, at the end you can also add null.  I will call it out.  And also, to make it more convenient,  instead of manually connecting  and moving these connections,  it would be more convenient  to just switch between them  using a slider or a parameter.  What if we need another floor?  This can be done differently.  If you want exactly the same as this one,  you can take the copy and transform node.  And instead of just lifting  I will turn off the grid.  Now we just raise it  to some random number.  We can also connect this parameter  from the height of the wall.  And everything works great.  We have a second floor.  But I want to use Wrangle again.  So that I have more opportunities  for direct control  if I want to change something later.  Again, write dog.py.  And I will take this one.  And I will take this one.  And I will take this one.  And I will take this one.  So, let's just copy and paste it.  And let's just copy and paste it.  Let's save a bit of time.  Ok. The last part doesn't need it.  Now let's combine them together.  At the end, I will not do this in a full-fledged setup, because we will work with these floors separately.  I just want to show you now how easy it is to start building such setups.  Now, if I change the height of the walls, everything will adjust.  So, let's summarize.  At the beginning, we can switch between the grid or the custom floor.  Here we can change the height of the walls.  And we can change their thickness.  If we do this, then we need to check that here it is also quite wide.  Let me increase the width.  So that we cut it correctly.  So, what else can we change?  How many windows do we have with this parameter?  Yes, so there will be more windows.  And we can change the size and location of the windows, since we did it a second ago.  Great, nothing has been spoiled.  Everything works great, we got a good basis.  And in the next lessons we will continue to add other elements. 
﻿WEBVTT  00:00:00.000 --> 00:00:02.000 Translated by the club Translated by everyone  00:00:03.120 --> 00:00:08.760 So, in the second lesson, we will start working with the windows and doors, or at least over the openings for the doors.  00:00:12.960 --> 00:00:18.140 Usually, when you create procedural buildings, it can be difficult to achieve the diversity that is needed and  00:00:18.880 --> 00:00:21.480 at the same time achieve a realistic result.  00:00:22.080 --> 00:00:27.600 In reality, there are no two identical buildings. It is this lack of repetition that must be taken into account when creating  00:00:27.600 --> 00:00:29.600 your own buildings and setups.  00:00:34.480 --> 00:00:39.400 As for the windows and doors, the approach will be the same as with the columns in the first week.  00:00:40.360 --> 00:00:42.360 Let's now analyze the process of creation.  00:00:43.720 --> 00:00:49.040 At first glance, the model may seem quite complex, at least complex in order to make it procedural.  00:00:50.040 --> 00:00:54.680 Now we will analyze the entire process and at the same time study some important things.  00:00:54.680 --> 00:01:04.400 If we look at the reference, then here we have doors and windows with flat tops and  00:01:05.480 --> 00:01:07.480 with curved ones.  00:01:07.880 --> 00:01:09.680 Somewhere they should be.  00:01:09.680 --> 00:01:11.680 Well, yes, there are doors too.  00:01:13.760 --> 00:01:21.880 Therefore, no matter what setup I create, we need to make sure that both of these features are taken into account there. We will discuss this during the work.  00:01:22.880 --> 00:01:28.039 And we will definitely show how to add as many variations as possible without complicating the setup.  00:01:29.000 --> 00:01:33.479 So, we return to the Houdini. We stopped at this in the last lesson.  00:01:34.720 --> 00:01:36.720 Let's switch back to the grid.  00:01:38.960 --> 00:01:42.479 And I want to make it bigger so that we have something to work with.  00:01:44.600 --> 00:01:46.600 Let's say 8x8.  00:01:49.080 --> 00:01:51.080 And while I turn off the upper floor.  00:01:51.880 --> 00:01:53.880 I will put these nodes aside.  00:01:59.880 --> 00:02:01.880 So, the first thing I noticed is that  00:02:02.880 --> 00:02:04.880 we created windows based on a box.  00:02:05.880 --> 00:02:09.880 And although there is nothing wrong with that, it is better to start from the grid.  00:02:10.880 --> 00:02:14.880 Because this way we can extrude it and get the same shape as here.  00:02:14.880 --> 00:02:17.880 But then it can also be useful for creating window frames.  00:02:18.880 --> 00:02:20.880 By the way, I will check the orientation again.  00:02:24.880 --> 00:02:26.880 I think I will turn off this additional turn.  00:02:28.880 --> 00:02:30.880 And change the shape of the window.  00:02:37.880 --> 00:02:39.880 Yes, probably so.  00:02:39.880 --> 00:02:41.880 It will be 0.6.  00:02:41.880 --> 00:02:43.880 Or a little wider.  00:02:43.880 --> 00:02:45.880 And this is the depth.  00:02:51.880 --> 00:02:53.880 The Boolie node will depend on it.  00:02:53.880 --> 00:02:56.880 Therefore, we need to make the walls wider or thicker.  00:02:57.880 --> 00:03:00.880 And the walls are also quite thick. Let's reduce them a little.  00:03:05.880 --> 00:03:06.880 Great.  00:03:06.880 --> 00:03:08.880 So it will be like this.  00:03:09.880 --> 00:03:10.880 Great.  00:03:10.880 --> 00:03:12.880 This will be better.  00:03:16.880 --> 00:03:18.880 So, let's start creating window frames.  00:03:19.880 --> 00:03:21.880 I'll take the grid.  00:03:22.880 --> 00:03:25.880 And we orient it the same way as this window.  00:03:26.880 --> 00:03:28.880 I add a polyextrude.  00:03:29.880 --> 00:03:31.880 We adjust the size.  00:03:43.880 --> 00:03:45.880 And we make the same thing with the other window.  00:03:46.880 --> 00:03:48.880 I will add a polyextrude.  00:03:49.880 --> 00:03:51.880 And I will make the same thing with the other window.  00:03:52.880 --> 00:03:54.880 And I will make the same thing with the other window.  00:03:54.880 --> 00:03:56.880 And I will make the same thing with the other window.  00:03:57.880 --> 00:03:59.880 And I will make the same thing with the other window.  00:04:00.880 --> 00:04:02.880 And I will make the same thing with the other window.  00:04:03.880 --> 00:04:05.880 And I will make the same thing with the other window.  00:04:06.880 --> 00:04:08.880 And I will make the same thing with the other window.  00:04:09.880 --> 00:04:11.880 And I will make the same thing with the other window.  00:04:12.880 --> 00:04:14.880 And I will make the same thing with the other window.  00:04:15.880 --> 00:04:17.880 And I will make the same thing with the other window.  00:04:18.880 --> 00:04:20.880 And I will make the same thing with the other window.  00:04:21.880 --> 00:04:23.880 And I will make the same thing with the other window.  00:04:24.880 --> 00:04:26.880 And I will make the same thing with the other window.  00:04:27.880 --> 00:04:29.880 And I will make the same thing with the other window.  00:04:30.880 --> 00:04:32.880 And I will make the same thing with the other window.  00:04:33.880 --> 00:04:35.880 And I will make the same thing with the other window.  00:04:36.880 --> 00:04:38.880 This way we willmusic the whole design.  00:04:39.880 --> 00:04:41.880 I will move the feet to the left edge of the window.  00:04:42.880 --> 00:04:44.880 I do not hope that the complete planner will blind a red person.  00:04:45.880 --> 00:04:49.880 And ...  00:04:50.880 --> 00:04:52.880 I will make an underwater movement.  00:04:52.880 --> 00:05:13.260 remove these check marks, remove the string, and in this case this is the x-axis, so let's say the dog  00:05:13.260 --> 00:05:18.900 p.x minus is equal to this distance divided by 2  00:05:24.780 --> 00:05:31.659 in fact, no, in the positive direction, plus is equal to super so we put it in the center of the world  00:05:31.659 --> 00:05:40.099 so we will have about the same result as before, the difference is that now we start from the grid  00:05:43.260 --> 00:05:47.980 it will be much better now we will see why I will change the width and so we have a grid  00:05:51.260 --> 00:05:51.980 add null  00:05:54.420 --> 00:05:59.340 and call windows here we start windows  00:06:06.219 --> 00:06:09.140 although probably you need to clarify this window frames  00:06:09.140 --> 00:06:17.659 ok if you have already worked in houdini for some time, then you should be familiar with some  00:06:17.659 --> 00:06:27.940 nodes, for example with such a node as oil extrude, I call it inset  00:06:33.300 --> 00:06:37.700 so we do the frames themselves we do not need the middle range  00:06:40.140 --> 00:06:44.260 and so we remove it  00:06:48.979 --> 00:06:56.219 I also want to divide these ribs and use the boolean node I will add the extrude field so that it is thick  00:06:59.460 --> 00:07:00.940 and I don't need the back  00:07:00.940 --> 00:07:08.780 part and sorry not boolean I wanted to add poly bevel  00:07:12.540 --> 00:07:16.700 super and we got such a good low polygonal shape  00:07:19.860 --> 00:07:25.420 and in most procedural setups, especially if you have large cities, this will be quite enough  00:07:25.420 --> 00:07:32.860 but if you want to make it more interesting, you can first divide them with a primitive node  00:07:41.940 --> 00:07:46.220 and then we do this and see what happens  00:07:46.220 --> 00:07:57.420 here it is necessary to turn it off and we see that additional details appeared in the corners I don't need it  00:07:57.420 --> 00:08:04.500 but I thought that you can leave it maybe someone will be interested super we have window frames  00:08:04.500 --> 00:08:06.260 let's continue to work  00:08:12.300 --> 00:08:14.260 so now we need internal details  00:08:16.220 --> 00:08:30.540 so here I will turn on the output front and also create a group for these polygons I will call xf extrusion front  00:08:33.140 --> 00:08:34.340 then I will add blast  00:08:40.460 --> 00:08:42.300 I will choose the extrusion front group  00:08:46.940 --> 00:08:49.620 and so we divided the outer and inner parts  00:08:51.740 --> 00:08:58.340 just select delete non-selected here will be the frame frame and here panels  00:09:00.740 --> 00:09:08.380 so well, here we just have one solid panel, of course, it does not fit, we need to do two, I will add a poly split  00:09:08.380 --> 00:09:15.340 add a node connect press enter  00:09:18.900 --> 00:09:22.700 you can do it like this, for example, click the right button to complete  00:09:26.460 --> 00:09:30.020 and now instead of dividing manually, we select the edge loop  00:09:33.700 --> 00:09:37.940 and you can add as much as I want, but I need one division  00:09:39.380 --> 00:09:46.939 and you can do the same thing that I can take everything here and add it like this  00:09:50.060 --> 00:09:55.460 I don't need blast I don't need the back part  00:09:59.020 --> 00:10:00.460 and that is, you don't need the front  00:10:08.380 --> 00:10:23.220 and now here we change to separate elements I will get two frames I think it's not bad, probably they are too wide  00:10:29.100 --> 00:10:33.660 and then we combine everything again normally we will fix later first I will add the merge  00:10:33.660 --> 00:10:37.260 and we already get a window  00:10:46.980 --> 00:10:53.380 at this stage you can already check how everything works so it seems great this means that if we  00:10:53.380 --> 00:10:59.180 go back to the beginning and decide to change the size of the windows we can do it so the next step  00:10:59.180 --> 00:11:06.339 is to make these panels from top to bottom I think you understand what we will do next  00:11:11.219 --> 00:11:12.099 I will take these nodes  00:11:18.380 --> 00:11:20.020 in general, let's use blast  00:11:20.020 --> 00:11:30.300 after that, here we export the front group  00:11:32.460 --> 00:11:38.420 if I click the middle button before this, we will see that we have this group of extrusion front  00:11:38.420 --> 00:11:44.500 because we created it here if we continue and do the same here in this node inset  00:11:45.460 --> 00:11:54.580 if we do not change this group, then this can lead to confusion, you can either call it somehow differently,  00:11:58.500 --> 00:12:05.700 for example, exdint internal and in the blast node you need to choose the right group  00:12:05.700 --> 00:12:17.900 so we get something like a waterfall when all the data continues to be transferred down  00:12:28.820 --> 00:12:31.780 now we check that everything works correctly so everything is fine  00:12:31.780 --> 00:12:35.819 yes like this  00:12:39.140 --> 00:12:46.900 so not bad now we take this blast move it to the side and delete non-selected  00:12:50.300 --> 00:12:52.020 so we will have internal parts  00:12:52.020 --> 00:13:02.180 further again we will divide only we will do horizontally I will add a split field  00:13:09.699 --> 00:13:14.740 it may seem that this is not quite a procedural decision, but since we do not plan to  00:13:14.740 --> 00:13:21.100 change the input geometry, it will always represent one plane and in this case we  00:13:21.100 --> 00:13:27.420 work on square windows so it's fine here we will have a good balance  00:13:27.420 --> 00:13:37.460 between procedural and non-procedural approaches if we can change the number of loops here  00:13:41.340 --> 00:13:43.140 so we need one and another  00:13:51.100 --> 00:14:02.220 and we will connect these two between ourselves I will copy the parameter I will insert a relative  00:14:02.220 --> 00:14:11.700 link I will make this green so that I understand that this is the main node and increase a little super  00:14:11.700 --> 00:14:22.940 so further we need a cycle for each now you will understand why  00:14:31.700 --> 00:14:33.300 for a start we divide them again  00:14:33.300 --> 00:14:43.699 and then add for each connected piece  00:14:50.699 --> 00:14:55.819 in general, we could sort out the polygons here, but this way will be better because  00:14:55.819 --> 00:14:58.099 we will not always work only with polygons  00:15:03.300 --> 00:15:10.380 let's turn on single pass so that we can see what it does  00:15:10.380 --> 00:15:17.540 and we want to add displacement because these panels should not be  00:15:17.540 --> 00:15:20.339 perfectly horizontal but with a slight turn  00:15:27.140 --> 00:15:31.339 here the pivot is somewhere in the middle I don't know maybe at zero most likely  00:15:31.340 --> 00:15:38.300 we want it to be in the center of the object so here I use a rather old technique  00:15:38.300 --> 00:15:51.740 but it still works we enter the dollar c and x dollar c and y and dollar c and z  00:15:51.740 --> 00:16:02.620 that is, x and y and z we center by x y and z and what is great this point will be  00:16:02.620 --> 00:16:11.660 centered in each iteration, look, it is now in the center and now you need to add only rotation  00:16:14.500 --> 00:16:18.580 and see what we get what we expected  00:16:22.620 --> 00:16:28.260 so we need to change the thickness we can again do this in the cycle for rich why not  00:16:34.060 --> 00:16:38.060 but again, depending on what kind of detail you need, you can  00:16:38.060 --> 00:16:45.380 add another poly bevel, I think I won't yet and let's combine everything  00:16:52.100 --> 00:16:59.020 and add the normal node just to create normal  00:17:04.460 --> 00:17:05.700 and change the angle to 20  00:17:11.380 --> 00:17:12.380 so it seems to be good  00:17:15.620 --> 00:17:19.700 so far we cannot of course determine where we have this separate  00:17:19.700 --> 00:17:23.540 panel we could see them during rendering, but now I will just add a poly bevel,  00:17:23.540 --> 00:17:26.660 if anything, it will be possible to remove it later,  00:17:31.780 --> 00:17:37.780 so all the windows are there and now let's try to copy them at the point  00:17:46.140 --> 00:17:47.420 instead of this we take these  00:17:50.700 --> 00:17:56.100 and see what we got, although they turned out the other way around, but we will fix this later  00:18:03.100 --> 00:18:04.140 and also in the merch  00:18:07.300 --> 00:18:11.700 let's correct the orientation I will come back and correct at the very beginning  00:18:14.460 --> 00:18:15.900 now I will just turn at the end  00:18:20.700 --> 00:18:26.740 although okay, let's leave it as it is, it's okay,  00:18:30.060 --> 00:18:31.700 let's look at the result,  00:18:33.860 --> 00:18:35.020 so they are only low,  00:18:37.780 --> 00:18:45.660 they also need to be transformed as here, we just raised them, sorry, here,  00:18:45.660 --> 00:18:49.580 I will copy and put it here,  00:18:52.580 --> 00:18:54.700 I think they need to be tied,  00:19:04.260 --> 00:19:11.500 fine, and we have windows, and if I change the input geometry, it should work perfectly,  00:19:16.060 --> 00:19:23.100 and even if you update in real time, don't pull up down only to the left to the right,  00:19:25.180 --> 00:19:33.660 fine, I think that's enough for a start, the next video we will continue and add variations,
﻿1 Translated by the club.  So far, all the windows look the same.  Let's consider some methods  with which you can make variations.  So, in our Forage cycle, which we have here,  we can, as in the first week,  activate the data node,  that is, create ...  it will give us some attributes  that can be used in each iteration of this cycle.  This is an iteration, that is, the transitions of these individual elements.  So, I will refer to these attributes in the data node.  And to make it easier for us,  let's rename it.  I will call it again, i.e. iteration.  So, what do we want to change?  We want to change this angle  or rotation of each of these elements.  Let's first define some axis.  So, here it is.  Here it is, rotation along the z-axis.  And I will refer to this attribute.  Again, we write the expression detail,  as in the first week.  Detail, then the path to the node itself.  If I wrote it manually,  it would be obj, go1,  the IT node.  Attribute iteration.  So, this worked.  Let's turn off PolyBevel for now.  But we see that this value,  the value of the metanode is applied to the geometry.  That is, the value of the metanode is applied to the geometry.  We can also see that this value  is applied to the geometry.  That is, each of these primitives has its own metadata.  They have numbers from 0 to 39.  Everything works as we expected,  but of course we want to randomize them.  Therefore, instead of using the attribute detail as it is,  we will use it as the initial value  for the expression random, as in the first week.  I will write rent and take it in brackets.  This also works.  But the value in the range from 0 to 1.  Therefore, the rotation is very small.  We need to change the range.  Again, we use fit01.  And I will remind you again.  fit01 takes a value  that is always in the range from 0 to 1.  This is the range that gives us the function random.  And in the end we want from 0 to, in my opinion,  minus 35.  I missed the mark.  And so we get randomization.  If we want to change it,  we have two ways.  You can add some number here.  We can add a number here.  We can add a number here.  This will be the initial value again.  Or after that, after dividing into primitives,  we can add a sort node.  Here again, select random.  And here we also have the initial value.  In general, you can use any method you like.  If we look at the final result,  we got exactly what we expected.  But now I want to create open and closed panels.  Let's work on this.  First, we need to somehow distinguish  the left half from the right.  Let's see where to add it.  And here we have the left half.  And here we have the right half.  And here we have the left half.  I think after polysplit we have ...  Yes, okay.  I'll add another primitive split.  Now we have two separate primitives.  And then I'll add a connectivity node.  Create a new attribute.  DOR.  And if we look at the table ...  Let's save it on primitives.  And I have DOR 0 and DOR 1.  And I have DOR 0 and DOR 1.  And I have DOR 0 and DOR 1.  Why is this necessary?  Since this attribute was installed at the beginning of the process,  it will still be there until the very end.  And at the end, if I turn this node on,  I'll return to the viewport.  And I'll add the delete node.  Actually, let's do it here.  Let's skip the main frame.  And here I will add the delete node.  And here we write the dog DOR, that is, the attribute is equal to 1.  So I will only have one door, one door.  And now I can call it the left left door.  Only you need to write correctly.  And of course the right door.  Only here you need to change to 0.  And if we decided to add an additional rotation,  we would take the transform node,  set the pivot in the center,  and then change the rotation.  If we took the transform and changed the pivot,  it would be done manually.  We can find some procedural way  if we change the size or shape of the object.  This rotation then coincided.  Let's start with the right door.  And let's think about how Houdini would do it.  We need to find the maximum position on the right  and the maximum position at the bottom along the y-axis.  That's where we want to move the pivot.  Houdini has a function that allows you to do this.  It's called bounding box.  We could take such a bounding box node  and work with it.  But if we have the opportunity to use VEX,  we will use it.  By the way, if you hold down shift  and move the node,  everything that is above it, everything connected to it,  moves.  And if you hold down control,  everything will move to the right side.  And I'll add an attribute Wrangle.  I'll call it Rotate.  And now I'll start writing getBBox.  And I'll have several options here.  Center, max, min, size and so on.  I need max, minx and miny.  We will study this in this course.  Let's start with max.  I'll write vector.  I want a vector variable.  I'll call it bbMax.  I create a new variable bbMax.  And I'll just pass the stream of geometry.  In this case, zero.  Nothing will happen yet,  because I haven't exported it as an attribute.  This variable exists only in Wrangle.  If I want to export, I need to write  fbbMaxX.  Now I'm already creating an attribute.  It's equal to  bbMax.x.  We take the value of x of this vector.  And the value it gets from this function.  If we check the points,  we will see this value.  Everything is fine.  But we need this value only once.  For the whole object in general.  That is, we need only one attribute.  So instead of sorting points,  we will work with the detail.  And here, look at the level of detail,  we have one attribute as we wanted.  And I said that we need max and minx,  and also miny.  I copy the line.  And instead of max, we write min.  And we write min.  Min.  This is again min.  That is, the attribute is also called miny.  And here bbMin.  We had to rename it.  So I have  maxx and miny.  And I'm going to put in the value  of the value of the value.  So maxx and miny.  Actually,  if we check the viewport,  then x is back,  and z is right and left.  That is, I need the maximum value of z.  Let me change.  And so it will be right.  And now, to shift the pivot,  I will take transform again.  And in the section pivot-transform,  we will refer to this attribute detail.  So, the expression detail.  We take it from the same node.  So, and we called it  bbMinY.  And again zero.  Oh, no, not that.  Not in that node.  It was in the Rotate node.  Sasha, there is y.  And you need to copy  for the position on z.  Only here we take the maximum.  And now the pivot is in the right place.  And then we will do the same  with the left door.  In general, in this case,  we need the value of minz.  That is, we do not need the maximum.  Here is miny.  And export.  Minz.  And now we will take  the maximum value of z.  Minz.  So, okay, we figured out the rotation.  Only how to randomize it now?  Because that's what we need.  We could, of course, open them manually.  And then use the attribute from pieces node.  Which will randomly  sort out different options.  And probably we use both  another method. But what if we want to do it  procedurally? That is, procedurally turn these  posts at different angles.  And a great way to do this is the copy stamp node.  Only before that, you need to check that these  attributes will be procedural.  With rotation, everything is fine, but we did not fix  here.  Let's fix it, it will be better.  Okay, and now let's look at the copy stamp node.  So, we need to add a copy stamp node.  In version 19.5, this node is already  outdated.  And in most cases we already use the 4-inch cycles  for stamping.  But now I want to take  exactly the copy stamp node.  I just want to show  how it works.  And by the way, this is a good lesson at the same time.  I will show you how to find outdated nodes that  were hidden. We open the textport.  And here we write  op-unhide.  Then sob, because this is exactly the sob node.  And copy.  And now if I write a copy in the editor  in the tab menu, I will have a copy stamp node.  Super, I need it.  Let's connect like this.  So, the windows are there, but they are scattered  everywhere.  You need to make it neat here.  So, we have windows, we want to add window frames.  I will add merge after that.  Here.  And this one too.  So, super. Now we have windows.  And there is still rotation left, let's remove it.  And now in the copy node we  turn on stamp inputs.  I want to rotate by y.  Here in the stamp copy node you announce  some of your variables. They can be called  as you like.  I will call it rot y.  And then you write what you want to add  to the value. I want there to be  random numbers.  And after you have determined what  the value should be, you connect again  to the transform node.  So, we need random numbers.  The initial value will be the point number  that goes from the right, the right input.  That is, the dog is drinking on us.  And we take this range from 0 to 1  and transform it into a new one.  From 0 to 90.  So, we announced the variable, we assigned it a value.  And now let's go back here and write  the expression with the stamp function.  It will return us a copy of what  is in this stamp node.  First we indicate the path.  This is the copy 1 node.  The variable name is rot y.  And again from 0. This is the default value.  If it cannot find any information there.  And look, we get a random rotation  from 0 to 90 degrees.  Super. And you need to repeat the same for the left door.  Only here you need minus 90,  because here the movement is already in the opposite direction.  I'll call it rot l.  And now we need to write the name of the node  and the name of the node.  And in the end we have windows that are  more closed or more open.  And we can change this value and correct their rotation.  Super. We got such open and closed windows.  Only the pivot position is not very successful.  As a result, such intersections are obtained here.  We can then adjust the bounding box expression  so that the pivot is at the front corner of the window,  not at the back.  But in any case, we still got variations.  Let's now look at the door.  The process will be almost the same.  Therefore, you can copy this setup  and thus create doors.  If you want to work with me,  then I think you should stop now  and as a homework create doors yourself  using exactly the same process.  And then when we come back, we will consider together  how to do it. 
﻿1   So this will be the last lesson dedicated to windows and doors.  As for the doors, I did the same actions, that is, I repeated the same setup, but since this is a door, I made it longer and added a couple more elements.  Let's move on to the houdini. I will tell you about the differences between windows and doors setups.  So, once again, I did all the same actions, but made the door longer.  I removed the lower face of the frame, so we only have a box from three sides left.  And added these upper wooden pieces. And I made a couple more things that I think should also be told.  To make the upper part, I used the poly split, but in it I used the edge percentage option.  So here we have a division exactly at 0.85. And look, I will change the height of the door, and this part is also adjusted.  Then, as I said, I removed the lower face.  To do this, I first added the sort node. This is to sort the primitives numbers, starting from the bottom.  Look, in the sort node, the number was changed to 0, because I changed the order, and then removed the zero primitive.  There are more effective ways to do the same, but I think this is enough for now. I will not complicate everything at once.  And then in the sort node, I also arranged the points in the same way.  So that the numeration does not go from here. I need these two, two and three.  And then in this wrangle, I took only points 2 and 3 and moved them to 0 along the y-axis.  And at the mesh, at the door, I made it so that the center position is half the height, so that the base always stood on the ground, that is, at 0 along the y.  Everything else is basically the same, except that there are a little more variations here.  This is because in this transform, I randomized not only the rotation along the z-axis, I added different shifts and in other channels.  That is, there are much more variations at the door.  And at the end, I also added these steps. When the height of the door changes, steps appear here.  Now in the first part we will discuss how to create this. I will delete this for now and we will recreate it again.  Here I will change it to 0.  First, we need a box.  The width will be the same as at the door.  I will add a little more space here.  And I will also add a little more space here.  And I will also add a little more space here.  The width will be the same as at the door.  Let's take this grid.  I will copy the first channel.  I already talked about this in the first week, but just in case, I remind you, if you want to know what the channel is called, its internal name,  type the cursor on the mark and you will see the name. This, for example, sizeX and sizeY.  I will add a link here.  And now it should have the correct width.  And again, we need the base to always be on the ground.  I will copy this parameter, put it here and divide it by two.  And we need the back part to always be in this plane.  You can do the same in the Z channel.  Great.  And now we can adjust the length.  And now we can adjust the length.  And now we can adjust the length.  The height by Y should coincide with this node in the transform. I will also copy and paste the link.  And now I will add a merge. Let's see what we got.  And we got a very simple setup. However, there are a couple of problems here.  If the door is too high, then of course it will be difficult to go there. If it is too low, then it will start to turn over and go below zero.  We will need to adjust this parameter so that it cannot go below zero, block it like this.  Let's add another box.  Let's first copy and paste this box, because I want to save something here.  But there will be several differences.  First, I want this height to always be equal to half of another box.  Now we have half of the box.  And we want to shift so that the base is always in front of it.  We have already set it so that the door is behind.  Now we need to add the Z channel of the first box.  First, I will add a link so that the length remains unchanged.  And then add to this channel.  And now, when we change the width of this box, it also adjusts.  If we change the height of this, they are always equal to half.  And if we lower it below zero, then everything will be spoiled.  We need to remove this lower step when the door is lowered below a certain height.  For this there is one very useful node. Switch If.  I will add Merge here.  So, we added the Switch If node.  And now we need to change the height of this.  This will be a smooth introduction to the If operator.  We will consider it in more detail when we study VEX.  If you are not familiar with the If operator, then it is usually used in programming and determines some rules.  If something happens, then do it this way or that way.  In this case, if something happens, we will do this.  As a result, we have such a setup in which there are these two steps.  We add to the second input.  And this setup, where there is only one step, we add here.  And add an expression.  Here we already have a certain expression and we say, if this channel ... I put it here.  If it is less than, say, one tenth, then what will happen in this case?  If this value is less than one tenth, then the node automatically switches.  I will do it like this.  No, I did it wrong.  It is necessary to do the opposite.  If the value is less than one tenth, we will lose this step.  In general, zero one seems to me to be very little.  Let's try zero two.  And we will see how it works.  We will add a new value.  And we will add a new value.  And we will add a new value.  And we will add a new value.  It turns out that we remove the steps or add them depending on the height of the door.  And we still have one problem.  To fix it, we need to add another switch.  And we will switch to null. Null is just an empty object.  We say that if it goes below zero, that is, 0.05, then we completely turn it off.  Like this. They disappear.  Again, it may be too high, but if we later adjust this height.  In general, this is how it is configured.  The last thing we need to do is move this whole setup back to our system with windows.  But so far we have a small mess here.  Let's start adding under the network, as I showed in the first week.  To group parts of the setup and make it more accurate.  And the last thing before we continue.  If I change the width of the door now, everything will be ruined again.  This is because the center is not changing.  It will be exactly in the middle of this size.  It would be possible to connect the channels again, I think it's not difficult.  Or we can just block this parameter.  If we change now, everything will remain the same.  So, okay, back to the network.  Let's put things in order here, add subnet.  Click tap and add subnet.  I want it to stay outside.  I'll highlight all this.  I'll cut it out and insert it under the network.  And now there are several events happening inside.  Here we have these input data from above.  There is an output node that is connected to the network.  We start with the input data. This is the grid, we connected it from above.  And here we connect like this.  And here.  And so we have the correct input geometry.  And here you also need to connect correctly at the output.  And here we connect the input data.  And here you also need to connect correctly at the output.  And everything works the same.  I'll call this rename frames, and this is proxy.  Now this is equal to zero, and this is one.  And to make it work, we need to add a new node.  And what's happening?  At the top level we have two outputs.  Output 1 and output 2.  I could open the interface editing window and change it,  but let's leave it for a later lesson,  when we will talk about creating assets.  For now I'll call it Windows.  And I'll connect to this node.  And it will work great.  Although we may have a couple of problems.  If I check the merge ...  Oh, no, everything is fine.  Why did I say that?  I thought we would need to check the correctness of the expressions.  Let's check them.  I'll delete them and write them again.  Because here I now need to go up to two levels to find the copy node.  This is what I was talking about.  And here the same.  Therefore, if you suddenly notice that the expression no longer works,  it is rather a mistake to add a new node.  And here the same.  Therefore, if you suddenly notice that the expression no longer works,  it is most likely due to the fact that you need to add an additional level.  So that the expression can find the desired node.  So, that's it.  I think that these two were the only things to be corrected.  And then we will do the same.  And here too.  So, good.  Then we will do the same with the doors.  We take all the necessary nodes and place the subnet.  So, I have already created another one for the network.  I called it door.  It is much like a network for Windows windows.  The difference is that since the doors look the other way,  I had to check that when I copy Proxy,  here I have a polyextrude and then I move back.  By Z.  Here you need to change it to a minus.  And instead of linking this transform at the base with the one at the beginning,  I did so that regardless of what the value of Y will be in this transform,  Proxy will have exactly the same.  So, and in my opinion, there is one more thing to correct.  This link to the channel.  These boxes were associated with the size of the grid.  And since the grid is at the top level,  here again it was necessary to correct in the expressions in the links.  So, good.  We got windows and doors.  How to add them back now?  Of course, we use exactly the same setup.  I will copy these.  We connect this here.  This here.  If you want, you can rename the nodes with a copy,  so that you understand that you are copying windows, doors and so on.  And before merging them, we need to decide  at which points there will be windows, and at which doors.  And we will do this.  The easiest way to do this is to take these existing points.  We know that each of them will be a window.  I will add the delete node.  I will call it windows.  We change to the point.  We will delete by range.  So we will have four points left.  Now we will copy here.  We will call it doors.  And here you can invert.  So we get the opposite.  Only we want to connect them together.  Now they are connected.  This means that if we decide to change the number of windows and doors,  everything will be updated correctly.  And here we connect the windows to windows, doors to doors.  And then you need to unite.  And the doors also need to be united.  Our doors will be turned in the wrong direction.  But it's okay, we will correct it later.  For now, we just connect them, unite.  And everything is fine, except that the doors are turned in the wrong direction.  Let's change their orientation.  This can be done at the very end in the pod-city.  I added a transform node here.  And I think you need to turn it 90 degrees.  I'm not quite sure which way to go.  Let's try.  If the nerfs don't work, we will turn it the other way.  Yes, we are lucky.  Super.  That's it, we have windows and doors.  But as I said, there are too many of them.  I think there are a lot of doors.  You can change the settings in the delete node.  Let the door be at every fourth point.  Or even at every eighth.  And so we have fewer doors.  And I think it's not bad at first.  This is a good basis, we have windows, we have doors.  And they are placed randomly.  We can check again that everything works as we expect.  And a good way to do this is to close the pod-city.  This means that we can go inside this node, change something, move and see how everything works.  Yes, everything is fine.  Okay, in the next lesson we will start discussing roofs.  We will start with low-polygon roofs, and then we will move to high-polygon ones.  And so we have a lot of windows.  And we have a lot of windows.  And we have a lot of windows.  And we will move to high-polygon ones. 
﻿1   So, we move on to creating a roof and we start with low-polygonal.  Since we are creating a large-scale environment, we need the opportunity to choose low-polygonal objects for more remote  or for larger large-scale cities or high-polygonal objects for larger plans.  We will start with the same low-polygonal and high-polygonal roofs.  But first we will create a low-polygonal, and then a high-polygonal one.  For the roof, we start again with the same plane that we used before.  And this, by the way, will be a good test. We can try to use the same.  What we are doing should work with both perfect squares and any floor shape that we choose.  Then we can be sure that our procedural setup is correct.  That is, regardless of what we do, our asset should work with what we pass on to it.  I have already created a roof, and now we will add another one.  I added a poly-expand node. I move here and add another null for the roof, I call it roof.  So, for a start, we need to change the offset. It should be large enough.  It turns out almost like extruding or inset.  I press W and you will see what happens.  In general, we need a fairly large value. I'll do 50.  In a couple of seconds I will explain why.  I will add a new node, and I will add a new node.  Well, I igna Santiago paste out here, for the purposes of the  A mountain of lights.  And now in the scene you will see how the  area between places is almost became more like sit on  And we need to enable the attribute edgeDistance.  I'll rename it, and call it height.  Because this attribute can be used to raise the central line.  Next, I'll show you how to configure it.  So now height is the top attribute.  Look here, on this tab.  0 is the border, and 1.5 is the inner part.  We want to save it on the points.  To do this, we add the attribute Promote node.  And now it will be the point attribute.  Now the point attribute.  The height attribute.  Again, if we check the table, we will see this attribute on the points tab.  This is so that we can use it in Wrangle.  And I think you can guess what operation we will perform here.  Just write SobakaPi.y  Plus is equal.  SobakaHeight.  And we get this displacement.  And it's great that it understands the order of the points.  And we get the right result.  But of course we need the ability to control this height.  Let's multiply by a new channel.  And we get the same result.  I'll write ChannelF.  And I'll call it Height.  Or we can call it RoofHeight.  To make it more understandable.  If we want, we can change it later.  Create a channel.  And we can change the value and make the roof high.  Or low, as you wish.  And for a low polygonal roof, this is quite enough.  I just want to add a small wooden frame.  On the reference, it was clear that it was located right along the curve.  It will be easy.  We can start with the same setup.  I'll take PolyExtrude to create an inset.  And I only need the front side, I don't need the sides.  And I'll add a small bug in the viewport.  It's good that you saw it.  Sometimes in Houdini there is a bug when it continues to show a node that you no longer show.  To reset the viewport, you just need to close it and open a new one.  And then it will be the same.  And then it will show the correct node.  We now have an inner line.  I'll add a sweep node.  And choose the SquareTube option.  We will get such a wooden structure.  And we combine everything again.  I rename it Wrangle.  RoofHeight.  And we get this frame at the bottom.  And now I fill in the holes at the bottom.  Here we have one polygon.  And we got the simplest roof.  This inner beam can be changed.  Or make it narrower, smaller.  This is done in the sweep node.  I think it's better this way.  I'll add a transform.  And lower it a little.  Super!  And in the end we got this roof.  I think it's too high.  Yes, that's better.  You can combine with everything else, but before doing this, let's make a high-polygonal roof first. 
﻿1   We are moving to high-polygonal roofs.  It should be noted that we will have several difficulties that need to be taken into account  if we take the already existing setup and use it to add roofs on top.  First, we need to extract curves and then perform their resampling,  and then correct the orientation of the curves for the central roof.  And for the main roof, we also need to move the normals.  We need to move them to the point where the roof that we copy to these points is in the correct orientation.  We will start with the central lines, pass the roof a simple shape,  and then, as we move, we will complicate it.  We return to the hut, I decided to start with a square roof so that it would be easier for us.  First, I will add a group node.  We need to separate these central ribs.  I will take the result from the roof height node.  And I don't need this polygon at the base, I only need the ribs on top.  I will call the center.  We group the edges.  And here we will have all the ribs.  I will press Enter if you do not see.  And to separate only the internal ribs, first we need to take the outer ones.  A quick way to do this is to take the same node and instead of the base group,  include include by edges and unshared edges.  And this is always a very good way to take these outer edges along the edge, along the contour.  And now we need to subtract one from the other.  This is called the center.  This is also called the center, but we need to subtract from the existing one.  As a result, only the internal ribs will remain.  And we want to separate them, that is, isolate.  Add the dissolve node.  Select Dissolve Non-Selected and turn on Create Curves when dissolving boundary.  And you had to select the group. Great.  We have almost everything we need.  Look, here we have points on top of each other.  We need to add a fuse for them to unite them.  Great.  And we still have the polygons that are still being applied.  I will add the Convert Line node.  As a result, there will be 4 primitives.  This is what we expect.  8 vertices, 5 points, everything is super.  Next, again, add the Resample node.  Another node that is used all the time.  Turn it off.  And here we increase the interval between the points.  Only for now they do not have the correct orientation.  Therefore, we add Orient and Long Curves.  And we add the Length Curve node.  And we add Orient and Long Curve.  And we direct the Y-axis up.  And in the end we got a good basis for copying something.  While we have nothing to copy, let's create a roof tile.  I'll take a mesh.  And the Bend node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  And the Length Curve node.  If you have never used the Bend node before, then do not worry, I think it is intuitively clear.  First you define the approximate direction, then you refine it.  And you correct the origin.  This can be done procedurally by tying the Capture Origin with a long or wide mesh.  But I will not do it, it will also go down.  Deform from both sides.  And add a little thickness.  I did not turn on Output Back, I do not need this part.  Then I will add a Copy node and we will correct the orientation.  So far everything is fine.  Only they were not placed quite correctly.  And I need to turn the Poset.  Now I will return to the Orient and Long Curves and I will use additional turns.  To correct their position.  I will turn it to 180.  You can do it here or turn it into a Transform, it does not matter.  I will turn it to 180.  I want to raise it a little with another turn.  Like this.  Slightly raise.  You can make them longer or add more.  I will make it a little shorter.  And this is what it turns out, something like a roof.  If I combine the bases, you will see a couple of problems that we need to solve.  Firstly, they are too low.  Again, we want to solve this procedurally.  And the easiest way is to use Bounding Box.  Reduce the bottom panel and use it in the Group node.  I will add Bound.  And from here we take points.  Look, we got a form that limits the container.  And change the Lower Padding a little.  Raise it a little.  Now add the Group node.  Group the points.  Here we choose the Keep and Bounding Regions option.  In the menu we select Bounding Object.  And look, this is how we remove this lower part.  I will call the Group Blast node.  I will add the Blast node.  We take this group and delete Non-Selected.  So we removed the bottom.  And now we need to raise it a little.  If you want to create a certain form, then you may want to remove the top.  But I don't want to remove it.  And then we get this form.  It's a little spoiled, but we'll fix it later.  And I think this is a good example of low-polygonal roofs.  Here you can apply texture and get a lot of interesting details.  At a distance, it will still look more interesting.  So, we have a good base.  Now we will create the roofs.  Next, we will discuss how to detail these sides of the roof.  The first way to add these high-polygonal skulls to the roof is the Breaker Polygons option in the Divide node.  I will add this node and show how it is done.  This is the Divide node.  And I'll take it from here.  And I'll add it to the Divide node.  Here we turn off Convex Polygons and turn on Breaker Polygons.  This is how we get such an even division of the surface.  Well, to remove this edge, you need to increase the size by Y.  That is, the division is performed by Y.  You can increase, you can decrease.  You can reduce.  See for yourself how you like it.  And we can adjust by X and Z.  And since we copy other objects to the points,  we need to make them evenly, at an even distance from each other.  That is, these squares should be of the same size.  Now I will add Copy to Points and see what happens in the end.  Yes, we copied the turtle, but it didn't work out quite right.  First, you need to correct the orientation.  Secondly, the turtle appeared here at the corners.  This should not be the case.  Let's start with the orientation.  For this we need an AppVector.  I will add the AttribCreate node.  We call the Attribut App.  This is a vector.  And let it be 1 and 1.  Thanks to this vector, the points will know where the top and where the bottom are.  That is, they will be correctly oriented.  And the second thing we need is Normals.  This is not always necessary, but just in case it is better that they were.  So that they are properly inherited.  Look, so we have Normals on the geometry.  But the problem is that they are mixed here.  This can be useful when you scatter vegetation, for example.  When you need it not to be all straight, but to have some kind of wave that passes through the field with grass.  So you can smooth Normals and get a good interpolation, but we don't need it.  Therefore, in the FESEC node we turn on the Cust Polygons, turn off the Orient and adjust the angle.  It would also be possible to take the ForEach cycle and process each primitive separately.  But it will do just fine.  Just need to turn them differently.  Just point them down.  Yes, great.  But we are missing a little, we need to do more.  Change the direction of the rotation.  And we need to make it more.  I will change the size so that they lie closer to each other, both by X and by Z.  I will turn off the frame.  And you need to add another copy.  To return it back.  And in the Merge node.  So, that was the first method.  And so we got perfectly aligned tiles.  Perhaps this is what you need.  And we can also use this limiting object.  We can slightly adjust them so that they are not too low.  I will copy and insert this setup here.  I think it would be possible to raise them a little higher, but I think you understood the idea.  This was the first option.  The second option.  Perhaps we want them to be slightly shifted, so that they do not lie so perfectly.  This will be the second way.  So, with this second method, we can place these tiles in the same position.  And we can also use this limiting object.  So, with this second method, we can place these tiles with a shift.  They will not lie so perfectly.  First, we need to cut this geometry.  We will do this with the Laps node.  This is the PolySlice node.  I will add it.  I will add it.  But first I need to quickly adjust the tiles.  I noticed that in the Bend node we had a slight shift.  We needed to nullify the origin to get it right.  And now in the Slice node, see what we get.  We just cut the geometry.  But first we need to turn it correctly.  We turn it Z.  We got such cuts.  And I will also change the size.  This is to take into account any changes in the roof that we can make later.  Let's increase.  And change it like this, because we need more.  In the end, we got separate parts on which we want to copy tiles.  But we don't need polygons, but ribs.  So we change to PolyLine.  And I will add more ConvertLine.  Then again Resample.  And Resample by Polygonage.  Then again Orient and Long Curve.  To adjust the correct rotation, Y is directed upwards.  I will connect and see what we get.  They appeared, but not in the right direction.  In Orient and Long Curve we use additional turns.  I need all three.  Here at 180.  So they will be turned upwards.  And they are turned 90 degrees, not in the right direction.  Let's turn it back.  And change the pitch.  So we lower them.  Super!  However, there are too many of them.  This also needs to be corrected.  Let's go back to Notary Sample.  What's great, when we change the parameters in Notary Sample, we see how the displacement changes.  If you change it slowly, you can make such an interesting displacement.  You can make another pattern.  So it turned out a completely different roof.  But now we can't take this Blast to do the same.  I add Null.  With the Blast node we can't take the lower row.  Because if we try to do it ...  I'll connect it here.  Look, so we lose these corner tiles.  Instead, with this setup, we need to remove the tile thickness and then use the Boolean node.  We will discuss this in the next video, when we will have a more reliable setup, more convenient.  We will stop here for now.  These were two ways to create a roof.  Of course, there are other.  And I would like to see what you can do with these setups.  How can you use them to create some of your own patterns.  Perhaps, if you have some other references, you can come up with some other ways to use this setup.  Well, at the end of this week, in the last video, we will create a balcony and detail the roof. 
Translated by the club  So, we have come to the final part of the second week.  We have already finished the rest of the building.  Now let's see how to add balconies and smokehouses.  And everything you learn in this lesson, you can use to add everything you like, any other elements of the roof.  Everything you need for your buildings.  Balconies, verandas, smokehouses and other elements of the roof and walls give us many additional options for choosing without much effort.  We will start with the balconies and the approach will be exactly the same as with windows and doors.  That is, we will have one single grid that will be controlled by the general form.  So, first of all, I will add a grid.  I will change its size.  I want a couple of meters per meter, but this can always be changed later.  And instead of setting up first, and then transfer through the subnet, let's start with the main building.  So, we for now Only the input data and the output data.  Input and Output  So, we need three or four different separate counters for the balconies.  And in this section, we want to build a building that has a technical Harun and Matos  we have moved from the nuclear abyss directly toward the abyss, off the roof.  Main building  First of all, the wallpaper.  So, for the balcony we need three or four different separate components that we combine together.  We need the boards of the foundation, the racks, the fence, the railing and the roof, the sloped roof.  And then, if we want something unusual, we can create something else at the bottom.  But in large environments this is not so important. Let's start creating the floor.  Let's take the Divide node again.  Again, we divide everything, we organize everything well at once, so I'll add a null.  Let's mark that this is the floor.  In the Divide node, again select, turn on the Breaker Polygons and adjust the size.  Make sure they are long and there are no divisions on the horizon.  Now you need to divide. This can be done differently.  The easiest way is to take the Poly Bevel node.  I'll increase the distance a little.  And I'll change the fillet shape to none.  Next, take the Poly Extrude node.  This was a quick way to create boards.  Of course, if we reduce the Bevel, the distance between them will decrease.  I think we need to leave it like this, smaller.  So that they are relatively close to each other.  Next, add another Poly Bevel after the Extrude.  Let's process the edges a little.  I think it's better this way.  And at the end, normal to correct the normals.  So, we got such a simple, good base.  And now we need to make the floor.  Actually, let's turn on the back side.  I'll put it back.  If we suddenly shoot from below, if the camera is located below, so that we don't have holes.  As we remember, at the entrance, we always have a hole in the middle.  So, we need to make a hole in the middle.  And we need to make a hole in the middle.  So, as we remember, at the entrance, we always have a grid.  And it is not necessary to select the edges procedurally.  That is, the input grid, its shape will never change.  So you can select the edges by hand here.  I will create a group for them.  I will call the frame.  Then I will add the dissolve node.  Here we select the frame group.  And create curves.  Turn on this flag below.  And dissolve non-selected.  So we will only have curves.  Next, we need a sweep node.  I will select the square tube.  I will reduce the posts and width.  And then we combine all this.  Well, now we have such bars along the contour.  Let's lower them a little.  And I will change the scale a little.  Yes, it will go well.  Now let's deal with the corners.  I will add another null.  I call cornerPosts.  And I will add another null.  And I will add another null.  And we already have the points that we need.  So there will be nothing complicated here.  Just take the box.  The base should be on the ground.  We already know how to do it.  No need to explain.  Now we need to think about the real scale of the balcony.  I think 2 meters is quite acceptable.  The height should be about 2 meters.  We are slightly adjusting the size of the grid.  And I will also connect these parameters, because  the height of the balcony should be about 2 meters.  And I will also connect these parameters, because  the height of the balcony should be about 2 meters.  And I will also connect these parameters, because  we need this rack to be square.  I will make it bigger.  Let's make 3 by 1.5 meters.  I think this will be right.  And just take Copy to Points.  We adjust the orientation by Orient and Long Curve.  And notice that normals are directed outside.  And notice that normals are directed outside.  That's how this node directed them.  And notice that normals are directed outside.  And notice that normals are directed outside.  This is how this node directed them.  The easiest way to fix this is to create a vector of the tangent along the z axis.  So, again, we have some kind of bug.  We need to close and open the viewport again. Just a bug.  Good. And merge them.  So, we have corner posts.  Just to make the design more logical.  I will increase the size and make them thicker.  I think it's better this way.  Next, we need perils.  I will move them to the side and add another null.  I will call it railings.  And again, we take only these three side ones and front ribs.  And again, we take only these three side ones and front ribs.  Group them.  Next, dissolve.  In general, you could copy this setup.  Or just take it as input data.  And so we will have what we need.  Although we don't need corner posts.  We need to delete them.  We will do it the same way as before.  With a sphere and a group.  And again, we take only these three side ones and front ribs.  And again, we take only these three side ones and front ribs.  And so we will have what we need.  We will take only these three sides.  And again, we take only these three side ones and front ribs.  And so we will have what we need.  With a sphere and a group.  With a sphere and a group.  And so we will have what we need.  I think it's the opposite.  I will try again.  Yes, that's right.  So, we've grouped the points, but of course we still need Resample nodes.  But not so many, of course.  Yes, I think it's better this way.  We need to turn on Resample by Polygon H.  Next, Blast.  And I'll call this group Blast too.  And we'll call this group Blast too.  Now we copy and we need to adjust it.  Super.  But they're too big. Let's reduce them by two.  And I'll change the scale.  And again in Merge.  And we need to adjust the scale.  Next, we need to add perils on top, just like the lower bar.  But only these perils should be at the right height.  So we need to connect channels with links with this node Transform.  Copy the parameter and paste the relative link.  Super.  I think they're too big.  Let's isolate these.  Actually, let's take it from here.  It will be more logical.  Perfect.  We have the posts, the perils, the floor and the frame.  We only need the roof.  Again, we have the original input geometry.  We'll do something similar to what we did with the floor.  It will be the roof roof.  I'll copy this whole setup.  And I'll add the same thing to the top.  And I'll add the same thing to the top.  And I'll add the same thing to the top.  It will be the roof roof.  I'll copy this whole setup.  I just want these boards to go not along Cx, but along Z.  So here you need to change places.  I'll make it bigger.  And we have the roof.  And it would be good to add some noise.  So that it's not so perfectly even.  You could take the CxFourEach and transform node in it.  To move them a little to the left and right.  And add a slight rotation.  I'll go back to the doors and take this setup.  I'll go back to the doors and take this setup.  I'll turn on the connectivity nodes.  I'll go back to the balconies and just put it here.  And connect.  So they will be a little different.  Variations will appear.  Okay? And we send it to Merge.  And of course we need to raise the roof up.  And of course we need to raise the roof up.  To the height of the racks.  Okay, super. We have the roof.  Let's make it a little bigger.  It looks good, but it seems strange to me that it's so flat.  Let's make it a little tilted.  You need to take this back edge and add a transform.  You can raise it as you like.  Let's say 0.2.  But it will not match these rear racks.  You need to highlight these points and raise them to the same height.  And since we know that the input data will not change,  I will not change the grid to a circle or something like that.  So I can just highlight the points manually.  Because they will not change.  Here.  No, here.  I'll take these points.  We take the points and add the edit node.  Copy the parameter from here.  Translate Y and paste it here.  Super. We got this balcony.  I think it's not bad.  Everything was done procedurally.  If we change the input grid proportions ...  Let me connect the output.  If we change the original grid, everything will be adjusted automatically.  Great.  Okay, let's do the smoke.  And as soon as we do them, we will connect everything with the main setup.  With the smoke it will be simple.  In theory, these are just boxes that we accidentally scatter on the roof.  But we will again use the polyslice node  to scatter only where we need it.  And again, we randomize the smoke with the attribute from pieces node.  We already talked about this.  I said that we would analyze this node in more detail.  And now we will just study it in more detail.  Attribute from pieces.  Here I have already started creating the smoke that I need.  Nothing new here.  I have already shown all this before.  There are just different smoke variants.  As soon as you create smoke or other elements of the roof,  you need to assign them the attribute name.  To do this, you need to add the name node.  This is so that you can use them with the attribute from pieces node.  I will call them chimpA, bc, but you can call them whatever you want.  Then we connect them all to the merge node and then to the output node.  We have already done all this in the subnet, as it should be.  And then we need to create the points on which we will scatter them.  For example, we will create a new node.  We will create a new node.  We will create a new node.  And we will create a new node.  And we will create a new node.  And we will create a new node.  And then we need to create the points on which we will scatter them.  The height will be the same as here.  Or at least similar.  These nodes are definitely needed here.  I just need to make less slices.  I will reduce these.  Well, that's what I think.  Let's make it even smaller.  Let's make it even smaller.  Here are the lines.  So far we have 8 primitives.  But this is not exactly what we need.  Because we need these corner points.  I want the smokehose to be scattered around the corners.  Instead of the convert line node, I will take polypass.  And if we check the primitives now ...  Here we have two continuous loops and only 8 points.  As we need.  Then I will add the delete node.  Just delete some points.  I will switch to delete by range.  Points and reduce the number of points.  Delete happens by the number of points.  But I want to randomize them like last time.  Then the removal will be more random.  And in the end I have 2 here and 2 there.  But still a lot.  I will delete, for example, 3 of each 5.  And now if I randomize them like this ...  So it turns out 2.  Okay, there will be 2 smokehoses.  So there are points, smokehoses.  Then we take the attribute from pieces node.  The node itself is very convenient.  On the right it takes the geometry, on the left the cloud of points.  As an attribute, the name is already installed here.  As we need.  And I will change the mode to random.  And here I want to choose ...  In the random section I will select piece weights.  This is such a great workflow when you have standard smokehoses, which are easy to create.  But from time to time you need something more unique.  Then I need the copy to points node.  Again, here is the geometry.  Here are the points that we copy.  So far, all the smokehoses are copied to each point.  Because we did not include the attribute.  Here again the name is written.  And so far nothing, because we did not fill.  You need to press autoFillPieces.  And now you need to change the weight.  You can change the initial value of seed and then change the weight.  You can make some smaller, some bigger or just make and somehow balance.  So that the distribution is uniform.  If they all have the same value, then they will be copied evenly.  Instead of smokehoses, you could also scatter any other elements of the roof.  And I placed them at the corners, but you could again scatter them all over the roof.  It seems to me that they are too high, but I think it's okay.  We could make the quality a little better if we used the boolean node for the smokehoses.  And we removed the tile in those places where we copied them.  But I think it will also go down.  And the last thing we need to add is the balconies in this setup.  The balconies should only be on the second and third floors.  Or on the fourth.  If you use them as a verand, then they should only be on the first floor.  But they should be added where the doors are.  That is, we do not want them to be where the windows are.  They should be with doors.  Let's move them here.  So, where do we have booleans here?  So, this is here.  And if I add balconies,  the balcony will appear on each door, but not quite right.  We need to turn them.  So, we have a balcony on each door.  And although they cut through, it turned out wrong, of course.  In the next lesson, we will correct and remove these steps, so everything will be fine.  And the last thing we need to do is to add the balconies.  We need to add them to the second and third floors.  And we will add them to the third and fourth floors.  And we will add them to the fourth and fifth floors.  And we will correct and remove these steps, so everything will be fine.  And so far they have been added to each door.  I think this is normal, because when we move to the other floors,  we will leave them on each door.  Just further these doors will be less.  So, okay.  I'm quite satisfied with what I've got.  In the end, I think we need to add other floors and a roof.  But we will do this next week.  And on this week I will tell you how to create a self-set.  We can already connect everything, unite everything.  We will set up the whole setup, create links to channels and connections between parameters.  And we will take them to the top level.  We will do all this next week.  And we will also talk about what kind of homework awaits you.  So, this week we discussed a lot of things.  There was a lot of new information.  So, the homework is to repeat everything we did in the lessons.  You will also need to create doors yourself.  This is what I did in the breaks between the lessons.  And you can create your own variations.  That is, do not what I have, make your own doors, some others, some other windows.  In general, try to repeat what I showed, but do not forget to use your imagination.  Create your own setups.  Let me show you my references again.  What buildings I have here.  For my scene, I took a lot from here.  I did a lot. I will definitely show you my setups.  And practically for everything I show here, the same methods are used, which we studied.  You can try to create these shapes.  Here are arcs, curved doors.  Such dome-shaped arches and so on.  In general, for this you use the same techniques. 